// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/witchs-lounge_backend/ent/achievement"
	"github.com/witchs-lounge_backend/ent/character"
	"github.com/witchs-lounge_backend/ent/item"
	"github.com/witchs-lounge_backend/ent/music"
	"github.com/witchs-lounge_backend/ent/predicate"
	"github.com/witchs-lounge_backend/ent/product"
	"github.com/witchs-lounge_backend/ent/record"
	"github.com/witchs-lounge_backend/ent/stage"
	"github.com/witchs-lounge_backend/ent/user"
	"github.com/witchs-lounge_backend/ent/userachievement"
	"github.com/witchs-lounge_backend/ent/userpurchase"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAchievement     = "Achievement"
	TypeCharacter       = "Character"
	TypeItem            = "Item"
	TypeMusic           = "Music"
	TypeProduct         = "Product"
	TypeRecord          = "Record"
	TypeStage           = "Stage"
	TypeUser            = "User"
	TypeUserAchievement = "UserAchievement"
	TypeUserPurchase    = "UserPurchase"
)

// AchievementMutation represents an operation that mutates the Achievement nodes in the graph.
type AchievementMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	name                     *string
	description              *string
	icon_url                 *string
	_type                    *achievement.Type
	conditions               *map[string]interface{}
	rewards                  *map[string]interface{}
	points                   *int
	addpoints                *int
	is_hidden                *bool
	is_active                *bool
	clearedFields            map[string]struct{}
	user_achievements        map[uuid.UUID]struct{}
	removeduser_achievements map[uuid.UUID]struct{}
	cleareduser_achievements bool
	done                     bool
	oldValue                 func(context.Context) (*Achievement, error)
	predicates               []predicate.Achievement
}

var _ ent.Mutation = (*AchievementMutation)(nil)

// achievementOption allows management of the mutation configuration using functional options.
type achievementOption func(*AchievementMutation)

// newAchievementMutation creates new mutation for the Achievement entity.
func newAchievementMutation(c config, op Op, opts ...achievementOption) *AchievementMutation {
	m := &AchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAchievementID sets the ID field of the mutation.
func withAchievementID(id uuid.UUID) achievementOption {
	return func(m *AchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *Achievement
		)
		m.oldValue = func(ctx context.Context) (*Achievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Achievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAchievement sets the old Achievement of the mutation.
func withAchievement(node *Achievement) achievementOption {
	return func(m *AchievementMutation) {
		m.oldValue = func(context.Context) (*Achievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Achievement entities.
func (m *AchievementMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AchievementMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AchievementMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Achievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AchievementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AchievementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AchievementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AchievementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AchievementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AchievementMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AchievementMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AchievementMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AchievementMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AchievementMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AchievementMutation) ResetDescription() {
	m.description = nil
}

// SetIconURL sets the "icon_url" field.
func (m *AchievementMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *AchievementMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *AchievementMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[achievement.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *AchievementMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[achievement.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *AchievementMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, achievement.FieldIconURL)
}

// SetType sets the "type" field.
func (m *AchievementMutation) SetType(a achievement.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AchievementMutation) GetType() (r achievement.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldType(ctx context.Context) (v achievement.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AchievementMutation) ResetType() {
	m._type = nil
}

// SetConditions sets the "conditions" field.
func (m *AchievementMutation) SetConditions(value map[string]interface{}) {
	m.conditions = &value
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *AchievementMutation) Conditions() (r map[string]interface{}, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ResetConditions resets all changes to the "conditions" field.
func (m *AchievementMutation) ResetConditions() {
	m.conditions = nil
}

// SetRewards sets the "rewards" field.
func (m *AchievementMutation) SetRewards(value map[string]interface{}) {
	m.rewards = &value
}

// Rewards returns the value of the "rewards" field in the mutation.
func (m *AchievementMutation) Rewards() (r map[string]interface{}, exists bool) {
	v := m.rewards
	if v == nil {
		return
	}
	return *v, true
}

// OldRewards returns the old "rewards" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldRewards(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewards: %w", err)
	}
	return oldValue.Rewards, nil
}

// ResetRewards resets all changes to the "rewards" field.
func (m *AchievementMutation) ResetRewards() {
	m.rewards = nil
}

// SetPoints sets the "points" field.
func (m *AchievementMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *AchievementMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *AchievementMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *AchievementMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *AchievementMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *AchievementMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *AchievementMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *AchievementMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetIsActive sets the "is_active" field.
func (m *AchievementMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AchievementMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AchievementMutation) ResetIsActive() {
	m.is_active = nil
}

// AddUserAchievementIDs adds the "user_achievements" edge to the UserAchievement entity by ids.
func (m *AchievementMutation) AddUserAchievementIDs(ids ...uuid.UUID) {
	if m.user_achievements == nil {
		m.user_achievements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_achievements[ids[i]] = struct{}{}
	}
}

// ClearUserAchievements clears the "user_achievements" edge to the UserAchievement entity.
func (m *AchievementMutation) ClearUserAchievements() {
	m.cleareduser_achievements = true
}

// UserAchievementsCleared reports if the "user_achievements" edge to the UserAchievement entity was cleared.
func (m *AchievementMutation) UserAchievementsCleared() bool {
	return m.cleareduser_achievements
}

// RemoveUserAchievementIDs removes the "user_achievements" edge to the UserAchievement entity by IDs.
func (m *AchievementMutation) RemoveUserAchievementIDs(ids ...uuid.UUID) {
	if m.removeduser_achievements == nil {
		m.removeduser_achievements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_achievements, ids[i])
		m.removeduser_achievements[ids[i]] = struct{}{}
	}
}

// RemovedUserAchievements returns the removed IDs of the "user_achievements" edge to the UserAchievement entity.
func (m *AchievementMutation) RemovedUserAchievementsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_achievements {
		ids = append(ids, id)
	}
	return
}

// UserAchievementsIDs returns the "user_achievements" edge IDs in the mutation.
func (m *AchievementMutation) UserAchievementsIDs() (ids []uuid.UUID) {
	for id := range m.user_achievements {
		ids = append(ids, id)
	}
	return
}

// ResetUserAchievements resets all changes to the "user_achievements" edge.
func (m *AchievementMutation) ResetUserAchievements() {
	m.user_achievements = nil
	m.cleareduser_achievements = false
	m.removeduser_achievements = nil
}

// Where appends a list predicates to the AchievementMutation builder.
func (m *AchievementMutation) Where(ps ...predicate.Achievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Achievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Achievement).
func (m *AchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AchievementMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, achievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, achievement.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, achievement.FieldName)
	}
	if m.description != nil {
		fields = append(fields, achievement.FieldDescription)
	}
	if m.icon_url != nil {
		fields = append(fields, achievement.FieldIconURL)
	}
	if m._type != nil {
		fields = append(fields, achievement.FieldType)
	}
	if m.conditions != nil {
		fields = append(fields, achievement.FieldConditions)
	}
	if m.rewards != nil {
		fields = append(fields, achievement.FieldRewards)
	}
	if m.points != nil {
		fields = append(fields, achievement.FieldPoints)
	}
	if m.is_hidden != nil {
		fields = append(fields, achievement.FieldIsHidden)
	}
	if m.is_active != nil {
		fields = append(fields, achievement.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.CreatedAt()
	case achievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case achievement.FieldName:
		return m.Name()
	case achievement.FieldDescription:
		return m.Description()
	case achievement.FieldIconURL:
		return m.IconURL()
	case achievement.FieldType:
		return m.GetType()
	case achievement.FieldConditions:
		return m.Conditions()
	case achievement.FieldRewards:
		return m.Rewards()
	case achievement.FieldPoints:
		return m.Points()
	case achievement.FieldIsHidden:
		return m.IsHidden()
	case achievement.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case achievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case achievement.FieldName:
		return m.OldName(ctx)
	case achievement.FieldDescription:
		return m.OldDescription(ctx)
	case achievement.FieldIconURL:
		return m.OldIconURL(ctx)
	case achievement.FieldType:
		return m.OldType(ctx)
	case achievement.FieldConditions:
		return m.OldConditions(ctx)
	case achievement.FieldRewards:
		return m.OldRewards(ctx)
	case achievement.FieldPoints:
		return m.OldPoints(ctx)
	case achievement.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case achievement.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Achievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case achievement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case achievement.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case achievement.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case achievement.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case achievement.FieldType:
		v, ok := value.(achievement.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case achievement.FieldConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case achievement.FieldRewards:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewards(v)
		return nil
	case achievement.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case achievement.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case achievement.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AchievementMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, achievement.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AchievementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(achievement.FieldIconURL) {
		fields = append(fields, achievement.FieldIconURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AchievementMutation) ClearField(name string) error {
	switch name {
	case achievement.FieldIconURL:
		m.ClearIconURL()
		return nil
	}
	return fmt.Errorf("unknown Achievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AchievementMutation) ResetField(name string) error {
	switch name {
	case achievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case achievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case achievement.FieldName:
		m.ResetName()
		return nil
	case achievement.FieldDescription:
		m.ResetDescription()
		return nil
	case achievement.FieldIconURL:
		m.ResetIconURL()
		return nil
	case achievement.FieldType:
		m.ResetType()
		return nil
	case achievement.FieldConditions:
		m.ResetConditions()
		return nil
	case achievement.FieldRewards:
		m.ResetRewards()
		return nil
	case achievement.FieldPoints:
		m.ResetPoints()
		return nil
	case achievement.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case achievement.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_achievements != nil {
		edges = append(edges, achievement.EdgeUserAchievements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AchievementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case achievement.EdgeUserAchievements:
		ids := make([]ent.Value, 0, len(m.user_achievements))
		for id := range m.user_achievements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_achievements != nil {
		edges = append(edges, achievement.EdgeUserAchievements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AchievementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case achievement.EdgeUserAchievements:
		ids := make([]ent.Value, 0, len(m.removeduser_achievements))
		for id := range m.removeduser_achievements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_achievements {
		edges = append(edges, achievement.EdgeUserAchievements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AchievementMutation) EdgeCleared(name string) bool {
	switch name {
	case achievement.EdgeUserAchievements:
		return m.cleareduser_achievements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AchievementMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Achievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AchievementMutation) ResetEdge(name string) error {
	switch name {
	case achievement.EdgeUserAchievements:
		m.ResetUserAchievements()
		return nil
	}
	return fmt.Errorf("unknown Achievement edge %s", name)
}

// CharacterMutation represents an operation that mutates the Character nodes in the graph.
type CharacterMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	source          *string
	clearedFields   map[string]struct{}
	products        map[uuid.UUID]struct{}
	removedproducts map[uuid.UUID]struct{}
	clearedproducts bool
	records         map[uuid.UUID]struct{}
	removedrecords  map[uuid.UUID]struct{}
	clearedrecords  bool
	done            bool
	oldValue        func(context.Context) (*Character, error)
	predicates      []predicate.Character
}

var _ ent.Mutation = (*CharacterMutation)(nil)

// characterOption allows management of the mutation configuration using functional options.
type characterOption func(*CharacterMutation)

// newCharacterMutation creates new mutation for the Character entity.
func newCharacterMutation(c config, op Op, opts ...characterOption) *CharacterMutation {
	m := &CharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterID sets the ID field of the mutation.
func withCharacterID(id uuid.UUID) characterOption {
	return func(m *CharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *Character
		)
		m.oldValue = func(ctx context.Context) (*Character, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Character.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacter sets the old Character of the mutation.
func withCharacter(node *Character) characterOption {
	return func(m *CharacterMutation) {
		m.oldValue = func(context.Context) (*Character, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Character entities.
func (m *CharacterMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Character.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CharacterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CharacterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CharacterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CharacterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CharacterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CharacterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CharacterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharacterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharacterMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CharacterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CharacterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CharacterMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[character.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CharacterMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[character.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CharacterMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, character.FieldDescription)
}

// SetSource sets the "source" field.
func (m *CharacterMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *CharacterMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *CharacterMutation) ResetSource() {
	m.source = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CharacterMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CharacterMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CharacterMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CharacterMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CharacterMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CharacterMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CharacterMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *CharacterMutation) AddRecordIDs(ids ...uuid.UUID) {
	if m.records == nil {
		m.records = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *CharacterMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *CharacterMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *CharacterMutation) RemoveRecordIDs(ids ...uuid.UUID) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *CharacterMutation) RemovedRecordsIDs() (ids []uuid.UUID) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *CharacterMutation) RecordsIDs() (ids []uuid.UUID) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *CharacterMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the CharacterMutation builder.
func (m *CharacterMutation) Where(ps ...predicate.Character) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Character, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Character).
func (m *CharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, character.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, character.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, character.FieldName)
	}
	if m.description != nil {
		fields = append(fields, character.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, character.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case character.FieldCreatedAt:
		return m.CreatedAt()
	case character.FieldUpdatedAt:
		return m.UpdatedAt()
	case character.FieldName:
		return m.Name()
	case character.FieldDescription:
		return m.Description()
	case character.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case character.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case character.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case character.FieldName:
		return m.OldName(ctx)
	case character.FieldDescription:
		return m.OldDescription(ctx)
	case character.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown Character field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case character.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case character.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case character.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case character.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case character.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Character numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(character.FieldDescription) {
		fields = append(fields, character.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterMutation) ClearField(name string) error {
	switch name {
	case character.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Character nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterMutation) ResetField(name string) error {
	switch name {
	case character.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case character.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case character.FieldName:
		m.ResetName()
		return nil
	case character.FieldDescription:
		m.ResetDescription()
		return nil
	case character.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, character.EdgeProducts)
	}
	if m.records != nil {
		edges = append(edges, character.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case character.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, character.EdgeProducts)
	}
	if m.removedrecords != nil {
		edges = append(edges, character.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case character.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, character.EdgeProducts)
	}
	if m.clearedrecords {
		edges = append(edges, character.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterMutation) EdgeCleared(name string) bool {
	switch name {
	case character.EdgeProducts:
		return m.clearedproducts
	case character.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Character unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterMutation) ResetEdge(name string) error {
	switch name {
	case character.EdgeProducts:
		m.ResetProducts()
		return nil
	case character.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown Character edge %s", name)
}

// ItemMutation represents an operation that mutates the Item nodes in the graph.
type ItemMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	effect_id       *string
	_type           *item.Type
	source          *string
	clearedFields   map[string]struct{}
	products        map[uuid.UUID]struct{}
	removedproducts map[uuid.UUID]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Item, error)
	predicates      []predicate.Item
}

var _ ent.Mutation = (*ItemMutation)(nil)

// itemOption allows management of the mutation configuration using functional options.
type itemOption func(*ItemMutation)

// newItemMutation creates new mutation for the Item entity.
func newItemMutation(c config, op Op, opts ...itemOption) *ItemMutation {
	m := &ItemMutation{
		config:        c,
		op:            op,
		typ:           TypeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemID sets the ID field of the mutation.
func withItemID(id uuid.UUID) itemOption {
	return func(m *ItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Item
		)
		m.oldValue = func(ctx context.Context) (*Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItem sets the old Item of the mutation.
func withItem(node *Item) itemOption {
	return func(m *ItemMutation) {
		m.oldValue = func(context.Context) (*Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Item entities.
func (m *ItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[item.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[item.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, item.FieldDescription)
}

// SetEffectID sets the "effect_id" field.
func (m *ItemMutation) SetEffectID(s string) {
	m.effect_id = &s
}

// EffectID returns the value of the "effect_id" field in the mutation.
func (m *ItemMutation) EffectID() (r string, exists bool) {
	v := m.effect_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectID returns the old "effect_id" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldEffectID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectID: %w", err)
	}
	return oldValue.EffectID, nil
}

// ClearEffectID clears the value of the "effect_id" field.
func (m *ItemMutation) ClearEffectID() {
	m.effect_id = nil
	m.clearedFields[item.FieldEffectID] = struct{}{}
}

// EffectIDCleared returns if the "effect_id" field was cleared in this mutation.
func (m *ItemMutation) EffectIDCleared() bool {
	_, ok := m.clearedFields[item.FieldEffectID]
	return ok
}

// ResetEffectID resets all changes to the "effect_id" field.
func (m *ItemMutation) ResetEffectID() {
	m.effect_id = nil
	delete(m.clearedFields, item.FieldEffectID)
}

// SetType sets the "type" field.
func (m *ItemMutation) SetType(i item.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ItemMutation) GetType() (r item.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldType(ctx context.Context) (v item.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ItemMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *ItemMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ItemMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Item entity.
// If the Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ItemMutation) ResetSource() {
	m.source = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ItemMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ItemMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ItemMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ItemMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ItemMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ItemMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ItemMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ItemMutation builder.
func (m *ItemMutation) Where(ps ...predicate.Item) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Item, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Item).
func (m *ItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, item.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, item.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, item.FieldName)
	}
	if m.description != nil {
		fields = append(fields, item.FieldDescription)
	}
	if m.effect_id != nil {
		fields = append(fields, item.FieldEffectID)
	}
	if m._type != nil {
		fields = append(fields, item.FieldType)
	}
	if m.source != nil {
		fields = append(fields, item.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case item.FieldCreatedAt:
		return m.CreatedAt()
	case item.FieldUpdatedAt:
		return m.UpdatedAt()
	case item.FieldName:
		return m.Name()
	case item.FieldDescription:
		return m.Description()
	case item.FieldEffectID:
		return m.EffectID()
	case item.FieldType:
		return m.GetType()
	case item.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case item.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case item.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case item.FieldName:
		return m.OldName(ctx)
	case item.FieldDescription:
		return m.OldDescription(ctx)
	case item.FieldEffectID:
		return m.OldEffectID(ctx)
	case item.FieldType:
		return m.OldType(ctx)
	case item.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case item.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case item.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case item.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case item.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case item.FieldEffectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectID(v)
		return nil
	case item.FieldType:
		v, ok := value.(item.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case item.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(item.FieldDescription) {
		fields = append(fields, item.FieldDescription)
	}
	if m.FieldCleared(item.FieldEffectID) {
		fields = append(fields, item.FieldEffectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemMutation) ClearField(name string) error {
	switch name {
	case item.FieldDescription:
		m.ClearDescription()
		return nil
	case item.FieldEffectID:
		m.ClearEffectID()
		return nil
	}
	return fmt.Errorf("unknown Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemMutation) ResetField(name string) error {
	switch name {
	case item.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case item.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case item.FieldName:
		m.ResetName()
		return nil
	case item.FieldDescription:
		m.ResetDescription()
		return nil
	case item.FieldEffectID:
		m.ResetEffectID()
		return nil
	case item.FieldType:
		m.ResetType()
		return nil
	case item.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, item.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, item.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case item.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, item.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemMutation) EdgeCleared(name string) bool {
	switch name {
	case item.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemMutation) ResetEdge(name string) error {
	switch name {
	case item.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Item edge %s", name)
}

// MusicMutation represents an operation that mutates the Music nodes in the graph.
type MusicMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	artist          *string
	composer        *string
	music_source    *string
	jacket_source   *string
	duration        *float64
	addduration     *float64
	bpm             *float64
	addbpm          *float64
	genre           *string
	description     *string
	is_featured     *bool
	is_free         *bool
	unlock_level    *int
	addunlock_level *int
	release_date    *time.Time
	is_active       *bool
	clearedFields   map[string]struct{}
	stages          map[uuid.UUID]struct{}
	removedstages   map[uuid.UUID]struct{}
	clearedstages   bool
	records         map[uuid.UUID]struct{}
	removedrecords  map[uuid.UUID]struct{}
	clearedrecords  bool
	done            bool
	oldValue        func(context.Context) (*Music, error)
	predicates      []predicate.Music
}

var _ ent.Mutation = (*MusicMutation)(nil)

// musicOption allows management of the mutation configuration using functional options.
type musicOption func(*MusicMutation)

// newMusicMutation creates new mutation for the Music entity.
func newMusicMutation(c config, op Op, opts ...musicOption) *MusicMutation {
	m := &MusicMutation{
		config:        c,
		op:            op,
		typ:           TypeMusic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMusicID sets the ID field of the mutation.
func withMusicID(id uuid.UUID) musicOption {
	return func(m *MusicMutation) {
		var (
			err   error
			once  sync.Once
			value *Music
		)
		m.oldValue = func(ctx context.Context) (*Music, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Music.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMusic sets the old Music of the mutation.
func withMusic(node *Music) musicOption {
	return func(m *MusicMutation) {
		m.oldValue = func(context.Context) (*Music, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MusicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MusicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Music entities.
func (m *MusicMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MusicMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MusicMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Music.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MusicMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MusicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MusicMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MusicMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MusicMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MusicMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MusicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MusicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MusicMutation) ResetName() {
	m.name = nil
}

// SetArtist sets the "artist" field.
func (m *MusicMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *MusicMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ResetArtist resets all changes to the "artist" field.
func (m *MusicMutation) ResetArtist() {
	m.artist = nil
}

// SetComposer sets the "composer" field.
func (m *MusicMutation) SetComposer(s string) {
	m.composer = &s
}

// Composer returns the value of the "composer" field in the mutation.
func (m *MusicMutation) Composer() (r string, exists bool) {
	v := m.composer
	if v == nil {
		return
	}
	return *v, true
}

// OldComposer returns the old "composer" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldComposer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComposer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComposer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComposer: %w", err)
	}
	return oldValue.Composer, nil
}

// ClearComposer clears the value of the "composer" field.
func (m *MusicMutation) ClearComposer() {
	m.composer = nil
	m.clearedFields[music.FieldComposer] = struct{}{}
}

// ComposerCleared returns if the "composer" field was cleared in this mutation.
func (m *MusicMutation) ComposerCleared() bool {
	_, ok := m.clearedFields[music.FieldComposer]
	return ok
}

// ResetComposer resets all changes to the "composer" field.
func (m *MusicMutation) ResetComposer() {
	m.composer = nil
	delete(m.clearedFields, music.FieldComposer)
}

// SetMusicSource sets the "music_source" field.
func (m *MusicMutation) SetMusicSource(s string) {
	m.music_source = &s
}

// MusicSource returns the value of the "music_source" field in the mutation.
func (m *MusicMutation) MusicSource() (r string, exists bool) {
	v := m.music_source
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicSource returns the old "music_source" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldMusicSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMusicSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMusicSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicSource: %w", err)
	}
	return oldValue.MusicSource, nil
}

// ResetMusicSource resets all changes to the "music_source" field.
func (m *MusicMutation) ResetMusicSource() {
	m.music_source = nil
}

// SetJacketSource sets the "jacket_source" field.
func (m *MusicMutation) SetJacketSource(s string) {
	m.jacket_source = &s
}

// JacketSource returns the value of the "jacket_source" field in the mutation.
func (m *MusicMutation) JacketSource() (r string, exists bool) {
	v := m.jacket_source
	if v == nil {
		return
	}
	return *v, true
}

// OldJacketSource returns the old "jacket_source" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldJacketSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJacketSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJacketSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJacketSource: %w", err)
	}
	return oldValue.JacketSource, nil
}

// ResetJacketSource resets all changes to the "jacket_source" field.
func (m *MusicMutation) ResetJacketSource() {
	m.jacket_source = nil
}

// SetDuration sets the "duration" field.
func (m *MusicMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MusicMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to the "duration" field.
func (m *MusicMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *MusicMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *MusicMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetBpm sets the "bpm" field.
func (m *MusicMutation) SetBpm(f float64) {
	m.bpm = &f
	m.addbpm = nil
}

// Bpm returns the value of the "bpm" field in the mutation.
func (m *MusicMutation) Bpm() (r float64, exists bool) {
	v := m.bpm
	if v == nil {
		return
	}
	return *v, true
}

// OldBpm returns the old "bpm" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldBpm(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBpm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBpm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBpm: %w", err)
	}
	return oldValue.Bpm, nil
}

// AddBpm adds f to the "bpm" field.
func (m *MusicMutation) AddBpm(f float64) {
	if m.addbpm != nil {
		*m.addbpm += f
	} else {
		m.addbpm = &f
	}
}

// AddedBpm returns the value that was added to the "bpm" field in this mutation.
func (m *MusicMutation) AddedBpm() (r float64, exists bool) {
	v := m.addbpm
	if v == nil {
		return
	}
	return *v, true
}

// ResetBpm resets all changes to the "bpm" field.
func (m *MusicMutation) ResetBpm() {
	m.bpm = nil
	m.addbpm = nil
}

// SetGenre sets the "genre" field.
func (m *MusicMutation) SetGenre(s string) {
	m.genre = &s
}

// Genre returns the value of the "genre" field in the mutation.
func (m *MusicMutation) Genre() (r string, exists bool) {
	v := m.genre
	if v == nil {
		return
	}
	return *v, true
}

// OldGenre returns the old "genre" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldGenre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenre: %w", err)
	}
	return oldValue.Genre, nil
}

// ClearGenre clears the value of the "genre" field.
func (m *MusicMutation) ClearGenre() {
	m.genre = nil
	m.clearedFields[music.FieldGenre] = struct{}{}
}

// GenreCleared returns if the "genre" field was cleared in this mutation.
func (m *MusicMutation) GenreCleared() bool {
	_, ok := m.clearedFields[music.FieldGenre]
	return ok
}

// ResetGenre resets all changes to the "genre" field.
func (m *MusicMutation) ResetGenre() {
	m.genre = nil
	delete(m.clearedFields, music.FieldGenre)
}

// SetDescription sets the "description" field.
func (m *MusicMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MusicMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MusicMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[music.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MusicMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[music.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MusicMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, music.FieldDescription)
}

// SetIsFeatured sets the "is_featured" field.
func (m *MusicMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *MusicMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *MusicMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// SetIsFree sets the "is_free" field.
func (m *MusicMutation) SetIsFree(b bool) {
	m.is_free = &b
}

// IsFree returns the value of the "is_free" field in the mutation.
func (m *MusicMutation) IsFree() (r bool, exists bool) {
	v := m.is_free
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "is_free" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldIsFree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// ResetIsFree resets all changes to the "is_free" field.
func (m *MusicMutation) ResetIsFree() {
	m.is_free = nil
}

// SetUnlockLevel sets the "unlock_level" field.
func (m *MusicMutation) SetUnlockLevel(i int) {
	m.unlock_level = &i
	m.addunlock_level = nil
}

// UnlockLevel returns the value of the "unlock_level" field in the mutation.
func (m *MusicMutation) UnlockLevel() (r int, exists bool) {
	v := m.unlock_level
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockLevel returns the old "unlock_level" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldUnlockLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockLevel: %w", err)
	}
	return oldValue.UnlockLevel, nil
}

// AddUnlockLevel adds i to the "unlock_level" field.
func (m *MusicMutation) AddUnlockLevel(i int) {
	if m.addunlock_level != nil {
		*m.addunlock_level += i
	} else {
		m.addunlock_level = &i
	}
}

// AddedUnlockLevel returns the value that was added to the "unlock_level" field in this mutation.
func (m *MusicMutation) AddedUnlockLevel() (r int, exists bool) {
	v := m.addunlock_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnlockLevel resets all changes to the "unlock_level" field.
func (m *MusicMutation) ResetUnlockLevel() {
	m.unlock_level = nil
	m.addunlock_level = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *MusicMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *MusicMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldReleaseDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *MusicMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[music.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *MusicMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[music.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *MusicMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, music.FieldReleaseDate)
}

// SetIsActive sets the "is_active" field.
func (m *MusicMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *MusicMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Music entity.
// If the Music object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MusicMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *MusicMutation) ResetIsActive() {
	m.is_active = nil
}

// AddStageIDs adds the "stages" edge to the Stage entity by ids.
func (m *MusicMutation) AddStageIDs(ids ...uuid.UUID) {
	if m.stages == nil {
		m.stages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.stages[ids[i]] = struct{}{}
	}
}

// ClearStages clears the "stages" edge to the Stage entity.
func (m *MusicMutation) ClearStages() {
	m.clearedstages = true
}

// StagesCleared reports if the "stages" edge to the Stage entity was cleared.
func (m *MusicMutation) StagesCleared() bool {
	return m.clearedstages
}

// RemoveStageIDs removes the "stages" edge to the Stage entity by IDs.
func (m *MusicMutation) RemoveStageIDs(ids ...uuid.UUID) {
	if m.removedstages == nil {
		m.removedstages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.stages, ids[i])
		m.removedstages[ids[i]] = struct{}{}
	}
}

// RemovedStages returns the removed IDs of the "stages" edge to the Stage entity.
func (m *MusicMutation) RemovedStagesIDs() (ids []uuid.UUID) {
	for id := range m.removedstages {
		ids = append(ids, id)
	}
	return
}

// StagesIDs returns the "stages" edge IDs in the mutation.
func (m *MusicMutation) StagesIDs() (ids []uuid.UUID) {
	for id := range m.stages {
		ids = append(ids, id)
	}
	return
}

// ResetStages resets all changes to the "stages" edge.
func (m *MusicMutation) ResetStages() {
	m.stages = nil
	m.clearedstages = false
	m.removedstages = nil
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *MusicMutation) AddRecordIDs(ids ...uuid.UUID) {
	if m.records == nil {
		m.records = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *MusicMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *MusicMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *MusicMutation) RemoveRecordIDs(ids ...uuid.UUID) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *MusicMutation) RemovedRecordsIDs() (ids []uuid.UUID) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *MusicMutation) RecordsIDs() (ids []uuid.UUID) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *MusicMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the MusicMutation builder.
func (m *MusicMutation) Where(ps ...predicate.Music) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MusicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MusicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Music, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MusicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MusicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Music).
func (m *MusicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MusicMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, music.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, music.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, music.FieldName)
	}
	if m.artist != nil {
		fields = append(fields, music.FieldArtist)
	}
	if m.composer != nil {
		fields = append(fields, music.FieldComposer)
	}
	if m.music_source != nil {
		fields = append(fields, music.FieldMusicSource)
	}
	if m.jacket_source != nil {
		fields = append(fields, music.FieldJacketSource)
	}
	if m.duration != nil {
		fields = append(fields, music.FieldDuration)
	}
	if m.bpm != nil {
		fields = append(fields, music.FieldBpm)
	}
	if m.genre != nil {
		fields = append(fields, music.FieldGenre)
	}
	if m.description != nil {
		fields = append(fields, music.FieldDescription)
	}
	if m.is_featured != nil {
		fields = append(fields, music.FieldIsFeatured)
	}
	if m.is_free != nil {
		fields = append(fields, music.FieldIsFree)
	}
	if m.unlock_level != nil {
		fields = append(fields, music.FieldUnlockLevel)
	}
	if m.release_date != nil {
		fields = append(fields, music.FieldReleaseDate)
	}
	if m.is_active != nil {
		fields = append(fields, music.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MusicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case music.FieldCreatedAt:
		return m.CreatedAt()
	case music.FieldUpdatedAt:
		return m.UpdatedAt()
	case music.FieldName:
		return m.Name()
	case music.FieldArtist:
		return m.Artist()
	case music.FieldComposer:
		return m.Composer()
	case music.FieldMusicSource:
		return m.MusicSource()
	case music.FieldJacketSource:
		return m.JacketSource()
	case music.FieldDuration:
		return m.Duration()
	case music.FieldBpm:
		return m.Bpm()
	case music.FieldGenre:
		return m.Genre()
	case music.FieldDescription:
		return m.Description()
	case music.FieldIsFeatured:
		return m.IsFeatured()
	case music.FieldIsFree:
		return m.IsFree()
	case music.FieldUnlockLevel:
		return m.UnlockLevel()
	case music.FieldReleaseDate:
		return m.ReleaseDate()
	case music.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MusicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case music.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case music.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case music.FieldName:
		return m.OldName(ctx)
	case music.FieldArtist:
		return m.OldArtist(ctx)
	case music.FieldComposer:
		return m.OldComposer(ctx)
	case music.FieldMusicSource:
		return m.OldMusicSource(ctx)
	case music.FieldJacketSource:
		return m.OldJacketSource(ctx)
	case music.FieldDuration:
		return m.OldDuration(ctx)
	case music.FieldBpm:
		return m.OldBpm(ctx)
	case music.FieldGenre:
		return m.OldGenre(ctx)
	case music.FieldDescription:
		return m.OldDescription(ctx)
	case music.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case music.FieldIsFree:
		return m.OldIsFree(ctx)
	case music.FieldUnlockLevel:
		return m.OldUnlockLevel(ctx)
	case music.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case music.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Music field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MusicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case music.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case music.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case music.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case music.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case music.FieldComposer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComposer(v)
		return nil
	case music.FieldMusicSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicSource(v)
		return nil
	case music.FieldJacketSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJacketSource(v)
		return nil
	case music.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case music.FieldBpm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBpm(v)
		return nil
	case music.FieldGenre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenre(v)
		return nil
	case music.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case music.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case music.FieldIsFree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case music.FieldUnlockLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockLevel(v)
		return nil
	case music.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case music.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Music field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MusicMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, music.FieldDuration)
	}
	if m.addbpm != nil {
		fields = append(fields, music.FieldBpm)
	}
	if m.addunlock_level != nil {
		fields = append(fields, music.FieldUnlockLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MusicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case music.FieldDuration:
		return m.AddedDuration()
	case music.FieldBpm:
		return m.AddedBpm()
	case music.FieldUnlockLevel:
		return m.AddedUnlockLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MusicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case music.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case music.FieldBpm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBpm(v)
		return nil
	case music.FieldUnlockLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnlockLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Music numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MusicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(music.FieldComposer) {
		fields = append(fields, music.FieldComposer)
	}
	if m.FieldCleared(music.FieldGenre) {
		fields = append(fields, music.FieldGenre)
	}
	if m.FieldCleared(music.FieldDescription) {
		fields = append(fields, music.FieldDescription)
	}
	if m.FieldCleared(music.FieldReleaseDate) {
		fields = append(fields, music.FieldReleaseDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MusicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MusicMutation) ClearField(name string) error {
	switch name {
	case music.FieldComposer:
		m.ClearComposer()
		return nil
	case music.FieldGenre:
		m.ClearGenre()
		return nil
	case music.FieldDescription:
		m.ClearDescription()
		return nil
	case music.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	}
	return fmt.Errorf("unknown Music nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MusicMutation) ResetField(name string) error {
	switch name {
	case music.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case music.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case music.FieldName:
		m.ResetName()
		return nil
	case music.FieldArtist:
		m.ResetArtist()
		return nil
	case music.FieldComposer:
		m.ResetComposer()
		return nil
	case music.FieldMusicSource:
		m.ResetMusicSource()
		return nil
	case music.FieldJacketSource:
		m.ResetJacketSource()
		return nil
	case music.FieldDuration:
		m.ResetDuration()
		return nil
	case music.FieldBpm:
		m.ResetBpm()
		return nil
	case music.FieldGenre:
		m.ResetGenre()
		return nil
	case music.FieldDescription:
		m.ResetDescription()
		return nil
	case music.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case music.FieldIsFree:
		m.ResetIsFree()
		return nil
	case music.FieldUnlockLevel:
		m.ResetUnlockLevel()
		return nil
	case music.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case music.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Music field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MusicMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.stages != nil {
		edges = append(edges, music.EdgeStages)
	}
	if m.records != nil {
		edges = append(edges, music.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MusicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case music.EdgeStages:
		ids := make([]ent.Value, 0, len(m.stages))
		for id := range m.stages {
			ids = append(ids, id)
		}
		return ids
	case music.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MusicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstages != nil {
		edges = append(edges, music.EdgeStages)
	}
	if m.removedrecords != nil {
		edges = append(edges, music.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MusicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case music.EdgeStages:
		ids := make([]ent.Value, 0, len(m.removedstages))
		for id := range m.removedstages {
			ids = append(ids, id)
		}
		return ids
	case music.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MusicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstages {
		edges = append(edges, music.EdgeStages)
	}
	if m.clearedrecords {
		edges = append(edges, music.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MusicMutation) EdgeCleared(name string) bool {
	switch name {
	case music.EdgeStages:
		return m.clearedstages
	case music.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MusicMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Music unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MusicMutation) ResetEdge(name string) error {
	switch name {
	case music.EdgeStages:
		m.ResetStages()
		return nil
	case music.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown Music edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	description           *string
	price                 *float64
	addprice              *float64
	_type                 *product.Type
	clearedFields         map[string]struct{}
	item                  *uuid.UUID
	cleareditem           bool
	character             *uuid.UUID
	clearedcharacter      bool
	purchasers            map[uuid.UUID]struct{}
	removedpurchasers     map[uuid.UUID]struct{}
	clearedpurchasers     bool
	user_purchases        map[uuid.UUID]struct{}
	removeduser_purchases map[uuid.UUID]struct{}
	cleareduser_purchases bool
	done                  bool
	oldValue              func(context.Context) (*Product, error)
	predicates            []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetType sets the "type" field.
func (m *ProductMutation) SetType(pr product.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductMutation) GetType() (r product.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldType(ctx context.Context) (v product.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProductMutation) ResetType() {
	m._type = nil
}

// SetItemID sets the "item" edge to the Item entity by id.
func (m *ProductMutation) SetItemID(id uuid.UUID) {
	m.item = &id
}

// ClearItem clears the "item" edge to the Item entity.
func (m *ProductMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the Item entity was cleared.
func (m *ProductMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *ProductMutation) ItemID() (id uuid.UUID, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) ItemIDs() (ids []uuid.UUID) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *ProductMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// SetCharacterID sets the "character" edge to the Character entity by id.
func (m *ProductMutation) SetCharacterID(id uuid.UUID) {
	m.character = &id
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *ProductMutation) ClearCharacter() {
	m.clearedcharacter = true
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *ProductMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// CharacterID returns the "character" edge ID in the mutation.
func (m *ProductMutation) CharacterID() (id uuid.UUID, exists bool) {
	if m.character != nil {
		return *m.character, true
	}
	return
}

// CharacterIDs returns the "character" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CharacterID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CharacterIDs() (ids []uuid.UUID) {
	if id := m.character; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *ProductMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
}

// AddPurchaserIDs adds the "purchasers" edge to the User entity by ids.
func (m *ProductMutation) AddPurchaserIDs(ids ...uuid.UUID) {
	if m.purchasers == nil {
		m.purchasers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.purchasers[ids[i]] = struct{}{}
	}
}

// ClearPurchasers clears the "purchasers" edge to the User entity.
func (m *ProductMutation) ClearPurchasers() {
	m.clearedpurchasers = true
}

// PurchasersCleared reports if the "purchasers" edge to the User entity was cleared.
func (m *ProductMutation) PurchasersCleared() bool {
	return m.clearedpurchasers
}

// RemovePurchaserIDs removes the "purchasers" edge to the User entity by IDs.
func (m *ProductMutation) RemovePurchaserIDs(ids ...uuid.UUID) {
	if m.removedpurchasers == nil {
		m.removedpurchasers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.purchasers, ids[i])
		m.removedpurchasers[ids[i]] = struct{}{}
	}
}

// RemovedPurchasers returns the removed IDs of the "purchasers" edge to the User entity.
func (m *ProductMutation) RemovedPurchasersIDs() (ids []uuid.UUID) {
	for id := range m.removedpurchasers {
		ids = append(ids, id)
	}
	return
}

// PurchasersIDs returns the "purchasers" edge IDs in the mutation.
func (m *ProductMutation) PurchasersIDs() (ids []uuid.UUID) {
	for id := range m.purchasers {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasers resets all changes to the "purchasers" edge.
func (m *ProductMutation) ResetPurchasers() {
	m.purchasers = nil
	m.clearedpurchasers = false
	m.removedpurchasers = nil
}

// AddUserPurchaseIDs adds the "user_purchases" edge to the UserPurchase entity by ids.
func (m *ProductMutation) AddUserPurchaseIDs(ids ...uuid.UUID) {
	if m.user_purchases == nil {
		m.user_purchases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_purchases[ids[i]] = struct{}{}
	}
}

// ClearUserPurchases clears the "user_purchases" edge to the UserPurchase entity.
func (m *ProductMutation) ClearUserPurchases() {
	m.cleareduser_purchases = true
}

// UserPurchasesCleared reports if the "user_purchases" edge to the UserPurchase entity was cleared.
func (m *ProductMutation) UserPurchasesCleared() bool {
	return m.cleareduser_purchases
}

// RemoveUserPurchaseIDs removes the "user_purchases" edge to the UserPurchase entity by IDs.
func (m *ProductMutation) RemoveUserPurchaseIDs(ids ...uuid.UUID) {
	if m.removeduser_purchases == nil {
		m.removeduser_purchases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_purchases, ids[i])
		m.removeduser_purchases[ids[i]] = struct{}{}
	}
}

// RemovedUserPurchases returns the removed IDs of the "user_purchases" edge to the UserPurchase entity.
func (m *ProductMutation) RemovedUserPurchasesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_purchases {
		ids = append(ids, id)
	}
	return
}

// UserPurchasesIDs returns the "user_purchases" edge IDs in the mutation.
func (m *ProductMutation) UserPurchasesIDs() (ids []uuid.UUID) {
	for id := range m.user_purchases {
		ids = append(ids, id)
	}
	return
}

// ResetUserPurchases resets all changes to the "user_purchases" edge.
func (m *ProductMutation) ResetUserPurchases() {
	m.user_purchases = nil
	m.cleareduser_purchases = false
	m.removeduser_purchases = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m._type != nil {
		fields = append(fields, product.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldPrice:
		return m.Price()
	case product.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldType:
		v, ok := value.(product.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.item != nil {
		edges = append(edges, product.EdgeItem)
	}
	if m.character != nil {
		edges = append(edges, product.EdgeCharacter)
	}
	if m.purchasers != nil {
		edges = append(edges, product.EdgePurchasers)
	}
	if m.user_purchases != nil {
		edges = append(edges, product.EdgeUserPurchases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeCharacter:
		if id := m.character; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgePurchasers:
		ids := make([]ent.Value, 0, len(m.purchasers))
		for id := range m.purchasers {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeUserPurchases:
		ids := make([]ent.Value, 0, len(m.user_purchases))
		for id := range m.user_purchases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpurchasers != nil {
		edges = append(edges, product.EdgePurchasers)
	}
	if m.removeduser_purchases != nil {
		edges = append(edges, product.EdgeUserPurchases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePurchasers:
		ids := make([]ent.Value, 0, len(m.removedpurchasers))
		for id := range m.removedpurchasers {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeUserPurchases:
		ids := make([]ent.Value, 0, len(m.removeduser_purchases))
		for id := range m.removeduser_purchases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareditem {
		edges = append(edges, product.EdgeItem)
	}
	if m.clearedcharacter {
		edges = append(edges, product.EdgeCharacter)
	}
	if m.clearedpurchasers {
		edges = append(edges, product.EdgePurchasers)
	}
	if m.cleareduser_purchases {
		edges = append(edges, product.EdgeUserPurchases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeItem:
		return m.cleareditem
	case product.EdgeCharacter:
		return m.clearedcharacter
	case product.EdgePurchasers:
		return m.clearedpurchasers
	case product.EdgeUserPurchases:
		return m.cleareduser_purchases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeItem:
		m.ClearItem()
		return nil
	case product.EdgeCharacter:
		m.ClearCharacter()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeItem:
		m.ResetItem()
		return nil
	case product.EdgeCharacter:
		m.ResetCharacter()
		return nil
	case product.EdgePurchasers:
		m.ResetPurchasers()
		return nil
	case product.EdgeUserPurchases:
		m.ResetUserPurchases()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// RecordMutation represents an operation that mutates the Record nodes in the graph.
type RecordMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	score            *int
	addscore         *int
	perfect_count    *int
	addperfect_count *int
	good_count       *int
	addgood_count    *int
	bad_count        *int
	addbad_count     *int
	miss_count       *int
	addmiss_count    *int
	max_combo        *int
	addmax_combo     *int
	accuracy         *float64
	addaccuracy      *float64
	rank             *record.Rank
	is_full_combo    *bool
	is_perfect_play  *bool
	played_at        *time.Time
	play_duration    *int
	addplay_duration *int
	additional_info  *map[string]interface{}
	is_valid         *bool
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	music            *uuid.UUID
	clearedmusic     bool
	stage            *uuid.UUID
	clearedstage     bool
	character        *uuid.UUID
	clearedcharacter bool
	done             bool
	oldValue         func(context.Context) (*Record, error)
	predicates       []predicate.Record
}

var _ ent.Mutation = (*RecordMutation)(nil)

// recordOption allows management of the mutation configuration using functional options.
type recordOption func(*RecordMutation)

// newRecordMutation creates new mutation for the Record entity.
func newRecordMutation(c config, op Op, opts ...recordOption) *RecordMutation {
	m := &RecordMutation{
		config:        c,
		op:            op,
		typ:           TypeRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecordID sets the ID field of the mutation.
func withRecordID(id uuid.UUID) recordOption {
	return func(m *RecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Record
		)
		m.oldValue = func(ctx context.Context) (*Record, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Record.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecord sets the old Record of the mutation.
func withRecord(node *Record) recordOption {
	return func(m *RecordMutation) {
		m.oldValue = func(context.Context) (*Record, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Record entities.
func (m *RecordMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecordMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecordMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Record.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RecordMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RecordMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RecordMutation) ResetUserID() {
	m.user = nil
}

// SetMusicID sets the "music_id" field.
func (m *RecordMutation) SetMusicID(u uuid.UUID) {
	m.music = &u
}

// MusicID returns the value of the "music_id" field in the mutation.
func (m *RecordMutation) MusicID() (r uuid.UUID, exists bool) {
	v := m.music
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicID returns the old "music_id" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldMusicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMusicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMusicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicID: %w", err)
	}
	return oldValue.MusicID, nil
}

// ResetMusicID resets all changes to the "music_id" field.
func (m *RecordMutation) ResetMusicID() {
	m.music = nil
}

// SetStageID sets the "stage_id" field.
func (m *RecordMutation) SetStageID(u uuid.UUID) {
	m.stage = &u
}

// StageID returns the value of the "stage_id" field in the mutation.
func (m *RecordMutation) StageID() (r uuid.UUID, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStageID returns the old "stage_id" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldStageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageID: %w", err)
	}
	return oldValue.StageID, nil
}

// ResetStageID resets all changes to the "stage_id" field.
func (m *RecordMutation) ResetStageID() {
	m.stage = nil
}

// SetCharacterID sets the "character_id" field.
func (m *RecordMutation) SetCharacterID(u uuid.UUID) {
	m.character = &u
}

// CharacterID returns the value of the "character_id" field in the mutation.
func (m *RecordMutation) CharacterID() (r uuid.UUID, exists bool) {
	v := m.character
	if v == nil {
		return
	}
	return *v, true
}

// OldCharacterID returns the old "character_id" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldCharacterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharacterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharacterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharacterID: %w", err)
	}
	return oldValue.CharacterID, nil
}

// ResetCharacterID resets all changes to the "character_id" field.
func (m *RecordMutation) ResetCharacterID() {
	m.character = nil
}

// SetScore sets the "score" field.
func (m *RecordMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *RecordMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *RecordMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *RecordMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *RecordMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetPerfectCount sets the "perfect_count" field.
func (m *RecordMutation) SetPerfectCount(i int) {
	m.perfect_count = &i
	m.addperfect_count = nil
}

// PerfectCount returns the value of the "perfect_count" field in the mutation.
func (m *RecordMutation) PerfectCount() (r int, exists bool) {
	v := m.perfect_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPerfectCount returns the old "perfect_count" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldPerfectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerfectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerfectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerfectCount: %w", err)
	}
	return oldValue.PerfectCount, nil
}

// AddPerfectCount adds i to the "perfect_count" field.
func (m *RecordMutation) AddPerfectCount(i int) {
	if m.addperfect_count != nil {
		*m.addperfect_count += i
	} else {
		m.addperfect_count = &i
	}
}

// AddedPerfectCount returns the value that was added to the "perfect_count" field in this mutation.
func (m *RecordMutation) AddedPerfectCount() (r int, exists bool) {
	v := m.addperfect_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerfectCount resets all changes to the "perfect_count" field.
func (m *RecordMutation) ResetPerfectCount() {
	m.perfect_count = nil
	m.addperfect_count = nil
}

// SetGoodCount sets the "good_count" field.
func (m *RecordMutation) SetGoodCount(i int) {
	m.good_count = &i
	m.addgood_count = nil
}

// GoodCount returns the value of the "good_count" field in the mutation.
func (m *RecordMutation) GoodCount() (r int, exists bool) {
	v := m.good_count
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodCount returns the old "good_count" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldGoodCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodCount: %w", err)
	}
	return oldValue.GoodCount, nil
}

// AddGoodCount adds i to the "good_count" field.
func (m *RecordMutation) AddGoodCount(i int) {
	if m.addgood_count != nil {
		*m.addgood_count += i
	} else {
		m.addgood_count = &i
	}
}

// AddedGoodCount returns the value that was added to the "good_count" field in this mutation.
func (m *RecordMutation) AddedGoodCount() (r int, exists bool) {
	v := m.addgood_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetGoodCount resets all changes to the "good_count" field.
func (m *RecordMutation) ResetGoodCount() {
	m.good_count = nil
	m.addgood_count = nil
}

// SetBadCount sets the "bad_count" field.
func (m *RecordMutation) SetBadCount(i int) {
	m.bad_count = &i
	m.addbad_count = nil
}

// BadCount returns the value of the "bad_count" field in the mutation.
func (m *RecordMutation) BadCount() (r int, exists bool) {
	v := m.bad_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBadCount returns the old "bad_count" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldBadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadCount: %w", err)
	}
	return oldValue.BadCount, nil
}

// AddBadCount adds i to the "bad_count" field.
func (m *RecordMutation) AddBadCount(i int) {
	if m.addbad_count != nil {
		*m.addbad_count += i
	} else {
		m.addbad_count = &i
	}
}

// AddedBadCount returns the value that was added to the "bad_count" field in this mutation.
func (m *RecordMutation) AddedBadCount() (r int, exists bool) {
	v := m.addbad_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBadCount resets all changes to the "bad_count" field.
func (m *RecordMutation) ResetBadCount() {
	m.bad_count = nil
	m.addbad_count = nil
}

// SetMissCount sets the "miss_count" field.
func (m *RecordMutation) SetMissCount(i int) {
	m.miss_count = &i
	m.addmiss_count = nil
}

// MissCount returns the value of the "miss_count" field in the mutation.
func (m *RecordMutation) MissCount() (r int, exists bool) {
	v := m.miss_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMissCount returns the old "miss_count" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldMissCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissCount: %w", err)
	}
	return oldValue.MissCount, nil
}

// AddMissCount adds i to the "miss_count" field.
func (m *RecordMutation) AddMissCount(i int) {
	if m.addmiss_count != nil {
		*m.addmiss_count += i
	} else {
		m.addmiss_count = &i
	}
}

// AddedMissCount returns the value that was added to the "miss_count" field in this mutation.
func (m *RecordMutation) AddedMissCount() (r int, exists bool) {
	v := m.addmiss_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMissCount resets all changes to the "miss_count" field.
func (m *RecordMutation) ResetMissCount() {
	m.miss_count = nil
	m.addmiss_count = nil
}

// SetMaxCombo sets the "max_combo" field.
func (m *RecordMutation) SetMaxCombo(i int) {
	m.max_combo = &i
	m.addmax_combo = nil
}

// MaxCombo returns the value of the "max_combo" field in the mutation.
func (m *RecordMutation) MaxCombo() (r int, exists bool) {
	v := m.max_combo
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxCombo returns the old "max_combo" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldMaxCombo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxCombo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxCombo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxCombo: %w", err)
	}
	return oldValue.MaxCombo, nil
}

// AddMaxCombo adds i to the "max_combo" field.
func (m *RecordMutation) AddMaxCombo(i int) {
	if m.addmax_combo != nil {
		*m.addmax_combo += i
	} else {
		m.addmax_combo = &i
	}
}

// AddedMaxCombo returns the value that was added to the "max_combo" field in this mutation.
func (m *RecordMutation) AddedMaxCombo() (r int, exists bool) {
	v := m.addmax_combo
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxCombo resets all changes to the "max_combo" field.
func (m *RecordMutation) ResetMaxCombo() {
	m.max_combo = nil
	m.addmax_combo = nil
}

// SetAccuracy sets the "accuracy" field.
func (m *RecordMutation) SetAccuracy(f float64) {
	m.accuracy = &f
	m.addaccuracy = nil
}

// Accuracy returns the value of the "accuracy" field in the mutation.
func (m *RecordMutation) Accuracy() (r float64, exists bool) {
	v := m.accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldAccuracy returns the old "accuracy" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldAccuracy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccuracy: %w", err)
	}
	return oldValue.Accuracy, nil
}

// AddAccuracy adds f to the "accuracy" field.
func (m *RecordMutation) AddAccuracy(f float64) {
	if m.addaccuracy != nil {
		*m.addaccuracy += f
	} else {
		m.addaccuracy = &f
	}
}

// AddedAccuracy returns the value that was added to the "accuracy" field in this mutation.
func (m *RecordMutation) AddedAccuracy() (r float64, exists bool) {
	v := m.addaccuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccuracy resets all changes to the "accuracy" field.
func (m *RecordMutation) ResetAccuracy() {
	m.accuracy = nil
	m.addaccuracy = nil
}

// SetRank sets the "rank" field.
func (m *RecordMutation) SetRank(r record.Rank) {
	m.rank = &r
}

// Rank returns the value of the "rank" field in the mutation.
func (m *RecordMutation) Rank() (r record.Rank, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldRank(ctx context.Context) (v record.Rank, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// ClearRank clears the value of the "rank" field.
func (m *RecordMutation) ClearRank() {
	m.rank = nil
	m.clearedFields[record.FieldRank] = struct{}{}
}

// RankCleared returns if the "rank" field was cleared in this mutation.
func (m *RecordMutation) RankCleared() bool {
	_, ok := m.clearedFields[record.FieldRank]
	return ok
}

// ResetRank resets all changes to the "rank" field.
func (m *RecordMutation) ResetRank() {
	m.rank = nil
	delete(m.clearedFields, record.FieldRank)
}

// SetIsFullCombo sets the "is_full_combo" field.
func (m *RecordMutation) SetIsFullCombo(b bool) {
	m.is_full_combo = &b
}

// IsFullCombo returns the value of the "is_full_combo" field in the mutation.
func (m *RecordMutation) IsFullCombo() (r bool, exists bool) {
	v := m.is_full_combo
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFullCombo returns the old "is_full_combo" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldIsFullCombo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFullCombo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFullCombo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFullCombo: %w", err)
	}
	return oldValue.IsFullCombo, nil
}

// ResetIsFullCombo resets all changes to the "is_full_combo" field.
func (m *RecordMutation) ResetIsFullCombo() {
	m.is_full_combo = nil
}

// SetIsPerfectPlay sets the "is_perfect_play" field.
func (m *RecordMutation) SetIsPerfectPlay(b bool) {
	m.is_perfect_play = &b
}

// IsPerfectPlay returns the value of the "is_perfect_play" field in the mutation.
func (m *RecordMutation) IsPerfectPlay() (r bool, exists bool) {
	v := m.is_perfect_play
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPerfectPlay returns the old "is_perfect_play" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldIsPerfectPlay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPerfectPlay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPerfectPlay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPerfectPlay: %w", err)
	}
	return oldValue.IsPerfectPlay, nil
}

// ResetIsPerfectPlay resets all changes to the "is_perfect_play" field.
func (m *RecordMutation) ResetIsPerfectPlay() {
	m.is_perfect_play = nil
}

// SetPlayedAt sets the "played_at" field.
func (m *RecordMutation) SetPlayedAt(t time.Time) {
	m.played_at = &t
}

// PlayedAt returns the value of the "played_at" field in the mutation.
func (m *RecordMutation) PlayedAt() (r time.Time, exists bool) {
	v := m.played_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayedAt returns the old "played_at" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldPlayedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayedAt: %w", err)
	}
	return oldValue.PlayedAt, nil
}

// ResetPlayedAt resets all changes to the "played_at" field.
func (m *RecordMutation) ResetPlayedAt() {
	m.played_at = nil
}

// SetPlayDuration sets the "play_duration" field.
func (m *RecordMutation) SetPlayDuration(i int) {
	m.play_duration = &i
	m.addplay_duration = nil
}

// PlayDuration returns the value of the "play_duration" field in the mutation.
func (m *RecordMutation) PlayDuration() (r int, exists bool) {
	v := m.play_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayDuration returns the old "play_duration" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldPlayDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayDuration: %w", err)
	}
	return oldValue.PlayDuration, nil
}

// AddPlayDuration adds i to the "play_duration" field.
func (m *RecordMutation) AddPlayDuration(i int) {
	if m.addplay_duration != nil {
		*m.addplay_duration += i
	} else {
		m.addplay_duration = &i
	}
}

// AddedPlayDuration returns the value that was added to the "play_duration" field in this mutation.
func (m *RecordMutation) AddedPlayDuration() (r int, exists bool) {
	v := m.addplay_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlayDuration clears the value of the "play_duration" field.
func (m *RecordMutation) ClearPlayDuration() {
	m.play_duration = nil
	m.addplay_duration = nil
	m.clearedFields[record.FieldPlayDuration] = struct{}{}
}

// PlayDurationCleared returns if the "play_duration" field was cleared in this mutation.
func (m *RecordMutation) PlayDurationCleared() bool {
	_, ok := m.clearedFields[record.FieldPlayDuration]
	return ok
}

// ResetPlayDuration resets all changes to the "play_duration" field.
func (m *RecordMutation) ResetPlayDuration() {
	m.play_duration = nil
	m.addplay_duration = nil
	delete(m.clearedFields, record.FieldPlayDuration)
}

// SetAdditionalInfo sets the "additional_info" field.
func (m *RecordMutation) SetAdditionalInfo(value map[string]interface{}) {
	m.additional_info = &value
}

// AdditionalInfo returns the value of the "additional_info" field in the mutation.
func (m *RecordMutation) AdditionalInfo() (r map[string]interface{}, exists bool) {
	v := m.additional_info
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalInfo returns the old "additional_info" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldAdditionalInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalInfo: %w", err)
	}
	return oldValue.AdditionalInfo, nil
}

// ClearAdditionalInfo clears the value of the "additional_info" field.
func (m *RecordMutation) ClearAdditionalInfo() {
	m.additional_info = nil
	m.clearedFields[record.FieldAdditionalInfo] = struct{}{}
}

// AdditionalInfoCleared returns if the "additional_info" field was cleared in this mutation.
func (m *RecordMutation) AdditionalInfoCleared() bool {
	_, ok := m.clearedFields[record.FieldAdditionalInfo]
	return ok
}

// ResetAdditionalInfo resets all changes to the "additional_info" field.
func (m *RecordMutation) ResetAdditionalInfo() {
	m.additional_info = nil
	delete(m.clearedFields, record.FieldAdditionalInfo)
}

// SetIsValid sets the "is_valid" field.
func (m *RecordMutation) SetIsValid(b bool) {
	m.is_valid = &b
}

// IsValid returns the value of the "is_valid" field in the mutation.
func (m *RecordMutation) IsValid() (r bool, exists bool) {
	v := m.is_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsValid returns the old "is_valid" field's value of the Record entity.
// If the Record object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordMutation) OldIsValid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsValid: %w", err)
	}
	return oldValue.IsValid, nil
}

// ResetIsValid resets all changes to the "is_valid" field.
func (m *RecordMutation) ResetIsValid() {
	m.is_valid = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[record.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RecordMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMusic clears the "music" edge to the Music entity.
func (m *RecordMutation) ClearMusic() {
	m.clearedmusic = true
	m.clearedFields[record.FieldMusicID] = struct{}{}
}

// MusicCleared reports if the "music" edge to the Music entity was cleared.
func (m *RecordMutation) MusicCleared() bool {
	return m.clearedmusic
}

// MusicIDs returns the "music" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MusicID instead. It exists only for internal usage by the builders.
func (m *RecordMutation) MusicIDs() (ids []uuid.UUID) {
	if id := m.music; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMusic resets all changes to the "music" edge.
func (m *RecordMutation) ResetMusic() {
	m.music = nil
	m.clearedmusic = false
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *RecordMutation) ClearStage() {
	m.clearedstage = true
	m.clearedFields[record.FieldStageID] = struct{}{}
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *RecordMutation) StageCleared() bool {
	return m.clearedstage
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *RecordMutation) StageIDs() (ids []uuid.UUID) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *RecordMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *RecordMutation) ClearCharacter() {
	m.clearedcharacter = true
	m.clearedFields[record.FieldCharacterID] = struct{}{}
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *RecordMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// CharacterIDs returns the "character" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CharacterID instead. It exists only for internal usage by the builders.
func (m *RecordMutation) CharacterIDs() (ids []uuid.UUID) {
	if id := m.character; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *RecordMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
}

// Where appends a list predicates to the RecordMutation builder.
func (m *RecordMutation) Where(ps ...predicate.Record) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Record, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Record).
func (m *RecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecordMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, record.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, record.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, record.FieldUserID)
	}
	if m.music != nil {
		fields = append(fields, record.FieldMusicID)
	}
	if m.stage != nil {
		fields = append(fields, record.FieldStageID)
	}
	if m.character != nil {
		fields = append(fields, record.FieldCharacterID)
	}
	if m.score != nil {
		fields = append(fields, record.FieldScore)
	}
	if m.perfect_count != nil {
		fields = append(fields, record.FieldPerfectCount)
	}
	if m.good_count != nil {
		fields = append(fields, record.FieldGoodCount)
	}
	if m.bad_count != nil {
		fields = append(fields, record.FieldBadCount)
	}
	if m.miss_count != nil {
		fields = append(fields, record.FieldMissCount)
	}
	if m.max_combo != nil {
		fields = append(fields, record.FieldMaxCombo)
	}
	if m.accuracy != nil {
		fields = append(fields, record.FieldAccuracy)
	}
	if m.rank != nil {
		fields = append(fields, record.FieldRank)
	}
	if m.is_full_combo != nil {
		fields = append(fields, record.FieldIsFullCombo)
	}
	if m.is_perfect_play != nil {
		fields = append(fields, record.FieldIsPerfectPlay)
	}
	if m.played_at != nil {
		fields = append(fields, record.FieldPlayedAt)
	}
	if m.play_duration != nil {
		fields = append(fields, record.FieldPlayDuration)
	}
	if m.additional_info != nil {
		fields = append(fields, record.FieldAdditionalInfo)
	}
	if m.is_valid != nil {
		fields = append(fields, record.FieldIsValid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case record.FieldCreatedAt:
		return m.CreatedAt()
	case record.FieldUpdatedAt:
		return m.UpdatedAt()
	case record.FieldUserID:
		return m.UserID()
	case record.FieldMusicID:
		return m.MusicID()
	case record.FieldStageID:
		return m.StageID()
	case record.FieldCharacterID:
		return m.CharacterID()
	case record.FieldScore:
		return m.Score()
	case record.FieldPerfectCount:
		return m.PerfectCount()
	case record.FieldGoodCount:
		return m.GoodCount()
	case record.FieldBadCount:
		return m.BadCount()
	case record.FieldMissCount:
		return m.MissCount()
	case record.FieldMaxCombo:
		return m.MaxCombo()
	case record.FieldAccuracy:
		return m.Accuracy()
	case record.FieldRank:
		return m.Rank()
	case record.FieldIsFullCombo:
		return m.IsFullCombo()
	case record.FieldIsPerfectPlay:
		return m.IsPerfectPlay()
	case record.FieldPlayedAt:
		return m.PlayedAt()
	case record.FieldPlayDuration:
		return m.PlayDuration()
	case record.FieldAdditionalInfo:
		return m.AdditionalInfo()
	case record.FieldIsValid:
		return m.IsValid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case record.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case record.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case record.FieldUserID:
		return m.OldUserID(ctx)
	case record.FieldMusicID:
		return m.OldMusicID(ctx)
	case record.FieldStageID:
		return m.OldStageID(ctx)
	case record.FieldCharacterID:
		return m.OldCharacterID(ctx)
	case record.FieldScore:
		return m.OldScore(ctx)
	case record.FieldPerfectCount:
		return m.OldPerfectCount(ctx)
	case record.FieldGoodCount:
		return m.OldGoodCount(ctx)
	case record.FieldBadCount:
		return m.OldBadCount(ctx)
	case record.FieldMissCount:
		return m.OldMissCount(ctx)
	case record.FieldMaxCombo:
		return m.OldMaxCombo(ctx)
	case record.FieldAccuracy:
		return m.OldAccuracy(ctx)
	case record.FieldRank:
		return m.OldRank(ctx)
	case record.FieldIsFullCombo:
		return m.OldIsFullCombo(ctx)
	case record.FieldIsPerfectPlay:
		return m.OldIsPerfectPlay(ctx)
	case record.FieldPlayedAt:
		return m.OldPlayedAt(ctx)
	case record.FieldPlayDuration:
		return m.OldPlayDuration(ctx)
	case record.FieldAdditionalInfo:
		return m.OldAdditionalInfo(ctx)
	case record.FieldIsValid:
		return m.OldIsValid(ctx)
	}
	return nil, fmt.Errorf("unknown Record field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case record.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case record.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case record.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case record.FieldMusicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicID(v)
		return nil
	case record.FieldStageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageID(v)
		return nil
	case record.FieldCharacterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterID(v)
		return nil
	case record.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case record.FieldPerfectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerfectCount(v)
		return nil
	case record.FieldGoodCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodCount(v)
		return nil
	case record.FieldBadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadCount(v)
		return nil
	case record.FieldMissCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissCount(v)
		return nil
	case record.FieldMaxCombo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxCombo(v)
		return nil
	case record.FieldAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccuracy(v)
		return nil
	case record.FieldRank:
		v, ok := value.(record.Rank)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case record.FieldIsFullCombo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFullCombo(v)
		return nil
	case record.FieldIsPerfectPlay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPerfectPlay(v)
		return nil
	case record.FieldPlayedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayedAt(v)
		return nil
	case record.FieldPlayDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayDuration(v)
		return nil
	case record.FieldAdditionalInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalInfo(v)
		return nil
	case record.FieldIsValid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsValid(v)
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecordMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, record.FieldScore)
	}
	if m.addperfect_count != nil {
		fields = append(fields, record.FieldPerfectCount)
	}
	if m.addgood_count != nil {
		fields = append(fields, record.FieldGoodCount)
	}
	if m.addbad_count != nil {
		fields = append(fields, record.FieldBadCount)
	}
	if m.addmiss_count != nil {
		fields = append(fields, record.FieldMissCount)
	}
	if m.addmax_combo != nil {
		fields = append(fields, record.FieldMaxCombo)
	}
	if m.addaccuracy != nil {
		fields = append(fields, record.FieldAccuracy)
	}
	if m.addplay_duration != nil {
		fields = append(fields, record.FieldPlayDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case record.FieldScore:
		return m.AddedScore()
	case record.FieldPerfectCount:
		return m.AddedPerfectCount()
	case record.FieldGoodCount:
		return m.AddedGoodCount()
	case record.FieldBadCount:
		return m.AddedBadCount()
	case record.FieldMissCount:
		return m.AddedMissCount()
	case record.FieldMaxCombo:
		return m.AddedMaxCombo()
	case record.FieldAccuracy:
		return m.AddedAccuracy()
	case record.FieldPlayDuration:
		return m.AddedPlayDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case record.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case record.FieldPerfectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerfectCount(v)
		return nil
	case record.FieldGoodCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoodCount(v)
		return nil
	case record.FieldBadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBadCount(v)
		return nil
	case record.FieldMissCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMissCount(v)
		return nil
	case record.FieldMaxCombo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxCombo(v)
		return nil
	case record.FieldAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccuracy(v)
		return nil
	case record.FieldPlayDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Record numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(record.FieldRank) {
		fields = append(fields, record.FieldRank)
	}
	if m.FieldCleared(record.FieldPlayDuration) {
		fields = append(fields, record.FieldPlayDuration)
	}
	if m.FieldCleared(record.FieldAdditionalInfo) {
		fields = append(fields, record.FieldAdditionalInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecordMutation) ClearField(name string) error {
	switch name {
	case record.FieldRank:
		m.ClearRank()
		return nil
	case record.FieldPlayDuration:
		m.ClearPlayDuration()
		return nil
	case record.FieldAdditionalInfo:
		m.ClearAdditionalInfo()
		return nil
	}
	return fmt.Errorf("unknown Record nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecordMutation) ResetField(name string) error {
	switch name {
	case record.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case record.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case record.FieldUserID:
		m.ResetUserID()
		return nil
	case record.FieldMusicID:
		m.ResetMusicID()
		return nil
	case record.FieldStageID:
		m.ResetStageID()
		return nil
	case record.FieldCharacterID:
		m.ResetCharacterID()
		return nil
	case record.FieldScore:
		m.ResetScore()
		return nil
	case record.FieldPerfectCount:
		m.ResetPerfectCount()
		return nil
	case record.FieldGoodCount:
		m.ResetGoodCount()
		return nil
	case record.FieldBadCount:
		m.ResetBadCount()
		return nil
	case record.FieldMissCount:
		m.ResetMissCount()
		return nil
	case record.FieldMaxCombo:
		m.ResetMaxCombo()
		return nil
	case record.FieldAccuracy:
		m.ResetAccuracy()
		return nil
	case record.FieldRank:
		m.ResetRank()
		return nil
	case record.FieldIsFullCombo:
		m.ResetIsFullCombo()
		return nil
	case record.FieldIsPerfectPlay:
		m.ResetIsPerfectPlay()
		return nil
	case record.FieldPlayedAt:
		m.ResetPlayedAt()
		return nil
	case record.FieldPlayDuration:
		m.ResetPlayDuration()
		return nil
	case record.FieldAdditionalInfo:
		m.ResetAdditionalInfo()
		return nil
	case record.FieldIsValid:
		m.ResetIsValid()
		return nil
	}
	return fmt.Errorf("unknown Record field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, record.EdgeUser)
	}
	if m.music != nil {
		edges = append(edges, record.EdgeMusic)
	}
	if m.stage != nil {
		edges = append(edges, record.EdgeStage)
	}
	if m.character != nil {
		edges = append(edges, record.EdgeCharacter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case record.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case record.EdgeMusic:
		if id := m.music; id != nil {
			return []ent.Value{*id}
		}
	case record.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case record.EdgeCharacter:
		if id := m.character; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, record.EdgeUser)
	}
	if m.clearedmusic {
		edges = append(edges, record.EdgeMusic)
	}
	if m.clearedstage {
		edges = append(edges, record.EdgeStage)
	}
	if m.clearedcharacter {
		edges = append(edges, record.EdgeCharacter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecordMutation) EdgeCleared(name string) bool {
	switch name {
	case record.EdgeUser:
		return m.cleareduser
	case record.EdgeMusic:
		return m.clearedmusic
	case record.EdgeStage:
		return m.clearedstage
	case record.EdgeCharacter:
		return m.clearedcharacter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecordMutation) ClearEdge(name string) error {
	switch name {
	case record.EdgeUser:
		m.ClearUser()
		return nil
	case record.EdgeMusic:
		m.ClearMusic()
		return nil
	case record.EdgeStage:
		m.ClearStage()
		return nil
	case record.EdgeCharacter:
		m.ClearCharacter()
		return nil
	}
	return fmt.Errorf("unknown Record unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecordMutation) ResetEdge(name string) error {
	switch name {
	case record.EdgeUser:
		m.ResetUser()
		return nil
	case record.EdgeMusic:
		m.ResetMusic()
		return nil
	case record.EdgeStage:
		m.ResetStage()
		return nil
	case record.EdgeCharacter:
		m.ResetCharacter()
		return nil
	}
	return fmt.Errorf("unknown Record edge %s", name)
}

// StageMutation represents an operation that mutates the Stage nodes in the graph.
type StageMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	level_name     *string
	difficulty     *int
	adddifficulty  *int
	level_address  *string
	jacket_address *string
	total_notes    *int
	addtotal_notes *int
	max_combo      *int
	addmax_combo   *int
	is_active      *bool
	clearedFields  map[string]struct{}
	music          *uuid.UUID
	clearedmusic   bool
	records        map[uuid.UUID]struct{}
	removedrecords map[uuid.UUID]struct{}
	clearedrecords bool
	done           bool
	oldValue       func(context.Context) (*Stage, error)
	predicates     []predicate.Stage
}

var _ ent.Mutation = (*StageMutation)(nil)

// stageOption allows management of the mutation configuration using functional options.
type stageOption func(*StageMutation)

// newStageMutation creates new mutation for the Stage entity.
func newStageMutation(c config, op Op, opts ...stageOption) *StageMutation {
	m := &StageMutation{
		config:        c,
		op:            op,
		typ:           TypeStage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStageID sets the ID field of the mutation.
func withStageID(id uuid.UUID) stageOption {
	return func(m *StageMutation) {
		var (
			err   error
			once  sync.Once
			value *Stage
		)
		m.oldValue = func(ctx context.Context) (*Stage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStage sets the old Stage of the mutation.
func withStage(node *Stage) stageOption {
	return func(m *StageMutation) {
		m.oldValue = func(context.Context) (*Stage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stage entities.
func (m *StageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMusicID sets the "music_id" field.
func (m *StageMutation) SetMusicID(u uuid.UUID) {
	m.music = &u
}

// MusicID returns the value of the "music_id" field in the mutation.
func (m *StageMutation) MusicID() (r uuid.UUID, exists bool) {
	v := m.music
	if v == nil {
		return
	}
	return *v, true
}

// OldMusicID returns the old "music_id" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldMusicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMusicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMusicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMusicID: %w", err)
	}
	return oldValue.MusicID, nil
}

// ResetMusicID resets all changes to the "music_id" field.
func (m *StageMutation) ResetMusicID() {
	m.music = nil
}

// SetLevelName sets the "level_name" field.
func (m *StageMutation) SetLevelName(s string) {
	m.level_name = &s
}

// LevelName returns the value of the "level_name" field in the mutation.
func (m *StageMutation) LevelName() (r string, exists bool) {
	v := m.level_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelName returns the old "level_name" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldLevelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelName: %w", err)
	}
	return oldValue.LevelName, nil
}

// ResetLevelName resets all changes to the "level_name" field.
func (m *StageMutation) ResetLevelName() {
	m.level_name = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *StageMutation) SetDifficulty(i int) {
	m.difficulty = &i
	m.adddifficulty = nil
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *StageMutation) Difficulty() (r int, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldDifficulty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// AddDifficulty adds i to the "difficulty" field.
func (m *StageMutation) AddDifficulty(i int) {
	if m.adddifficulty != nil {
		*m.adddifficulty += i
	} else {
		m.adddifficulty = &i
	}
}

// AddedDifficulty returns the value that was added to the "difficulty" field in this mutation.
func (m *StageMutation) AddedDifficulty() (r int, exists bool) {
	v := m.adddifficulty
	if v == nil {
		return
	}
	return *v, true
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *StageMutation) ResetDifficulty() {
	m.difficulty = nil
	m.adddifficulty = nil
}

// SetLevelAddress sets the "level_address" field.
func (m *StageMutation) SetLevelAddress(s string) {
	m.level_address = &s
}

// LevelAddress returns the value of the "level_address" field in the mutation.
func (m *StageMutation) LevelAddress() (r string, exists bool) {
	v := m.level_address
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelAddress returns the old "level_address" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldLevelAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelAddress: %w", err)
	}
	return oldValue.LevelAddress, nil
}

// ResetLevelAddress resets all changes to the "level_address" field.
func (m *StageMutation) ResetLevelAddress() {
	m.level_address = nil
}

// SetJacketAddress sets the "jacket_address" field.
func (m *StageMutation) SetJacketAddress(s string) {
	m.jacket_address = &s
}

// JacketAddress returns the value of the "jacket_address" field in the mutation.
func (m *StageMutation) JacketAddress() (r string, exists bool) {
	v := m.jacket_address
	if v == nil {
		return
	}
	return *v, true
}

// OldJacketAddress returns the old "jacket_address" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldJacketAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJacketAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJacketAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJacketAddress: %w", err)
	}
	return oldValue.JacketAddress, nil
}

// ResetJacketAddress resets all changes to the "jacket_address" field.
func (m *StageMutation) ResetJacketAddress() {
	m.jacket_address = nil
}

// SetTotalNotes sets the "total_notes" field.
func (m *StageMutation) SetTotalNotes(i int) {
	m.total_notes = &i
	m.addtotal_notes = nil
}

// TotalNotes returns the value of the "total_notes" field in the mutation.
func (m *StageMutation) TotalNotes() (r int, exists bool) {
	v := m.total_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalNotes returns the old "total_notes" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldTotalNotes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalNotes: %w", err)
	}
	return oldValue.TotalNotes, nil
}

// AddTotalNotes adds i to the "total_notes" field.
func (m *StageMutation) AddTotalNotes(i int) {
	if m.addtotal_notes != nil {
		*m.addtotal_notes += i
	} else {
		m.addtotal_notes = &i
	}
}

// AddedTotalNotes returns the value that was added to the "total_notes" field in this mutation.
func (m *StageMutation) AddedTotalNotes() (r int, exists bool) {
	v := m.addtotal_notes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalNotes resets all changes to the "total_notes" field.
func (m *StageMutation) ResetTotalNotes() {
	m.total_notes = nil
	m.addtotal_notes = nil
}

// SetMaxCombo sets the "max_combo" field.
func (m *StageMutation) SetMaxCombo(i int) {
	m.max_combo = &i
	m.addmax_combo = nil
}

// MaxCombo returns the value of the "max_combo" field in the mutation.
func (m *StageMutation) MaxCombo() (r int, exists bool) {
	v := m.max_combo
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxCombo returns the old "max_combo" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldMaxCombo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxCombo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxCombo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxCombo: %w", err)
	}
	return oldValue.MaxCombo, nil
}

// AddMaxCombo adds i to the "max_combo" field.
func (m *StageMutation) AddMaxCombo(i int) {
	if m.addmax_combo != nil {
		*m.addmax_combo += i
	} else {
		m.addmax_combo = &i
	}
}

// AddedMaxCombo returns the value that was added to the "max_combo" field in this mutation.
func (m *StageMutation) AddedMaxCombo() (r int, exists bool) {
	v := m.addmax_combo
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxCombo resets all changes to the "max_combo" field.
func (m *StageMutation) ResetMaxCombo() {
	m.max_combo = nil
	m.addmax_combo = nil
}

// SetIsActive sets the "is_active" field.
func (m *StageMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *StageMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *StageMutation) ResetIsActive() {
	m.is_active = nil
}

// ClearMusic clears the "music" edge to the Music entity.
func (m *StageMutation) ClearMusic() {
	m.clearedmusic = true
	m.clearedFields[stage.FieldMusicID] = struct{}{}
}

// MusicCleared reports if the "music" edge to the Music entity was cleared.
func (m *StageMutation) MusicCleared() bool {
	return m.clearedmusic
}

// MusicIDs returns the "music" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MusicID instead. It exists only for internal usage by the builders.
func (m *StageMutation) MusicIDs() (ids []uuid.UUID) {
	if id := m.music; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMusic resets all changes to the "music" edge.
func (m *StageMutation) ResetMusic() {
	m.music = nil
	m.clearedmusic = false
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *StageMutation) AddRecordIDs(ids ...uuid.UUID) {
	if m.records == nil {
		m.records = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *StageMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *StageMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *StageMutation) RemoveRecordIDs(ids ...uuid.UUID) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *StageMutation) RemovedRecordsIDs() (ids []uuid.UUID) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *StageMutation) RecordsIDs() (ids []uuid.UUID) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *StageMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the StageMutation builder.
func (m *StageMutation) Where(ps ...predicate.Stage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stage).
func (m *StageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, stage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stage.FieldUpdatedAt)
	}
	if m.music != nil {
		fields = append(fields, stage.FieldMusicID)
	}
	if m.level_name != nil {
		fields = append(fields, stage.FieldLevelName)
	}
	if m.difficulty != nil {
		fields = append(fields, stage.FieldDifficulty)
	}
	if m.level_address != nil {
		fields = append(fields, stage.FieldLevelAddress)
	}
	if m.jacket_address != nil {
		fields = append(fields, stage.FieldJacketAddress)
	}
	if m.total_notes != nil {
		fields = append(fields, stage.FieldTotalNotes)
	}
	if m.max_combo != nil {
		fields = append(fields, stage.FieldMaxCombo)
	}
	if m.is_active != nil {
		fields = append(fields, stage.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stage.FieldCreatedAt:
		return m.CreatedAt()
	case stage.FieldUpdatedAt:
		return m.UpdatedAt()
	case stage.FieldMusicID:
		return m.MusicID()
	case stage.FieldLevelName:
		return m.LevelName()
	case stage.FieldDifficulty:
		return m.Difficulty()
	case stage.FieldLevelAddress:
		return m.LevelAddress()
	case stage.FieldJacketAddress:
		return m.JacketAddress()
	case stage.FieldTotalNotes:
		return m.TotalNotes()
	case stage.FieldMaxCombo:
		return m.MaxCombo()
	case stage.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stage.FieldMusicID:
		return m.OldMusicID(ctx)
	case stage.FieldLevelName:
		return m.OldLevelName(ctx)
	case stage.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case stage.FieldLevelAddress:
		return m.OldLevelAddress(ctx)
	case stage.FieldJacketAddress:
		return m.OldJacketAddress(ctx)
	case stage.FieldTotalNotes:
		return m.OldTotalNotes(ctx)
	case stage.FieldMaxCombo:
		return m.OldMaxCombo(ctx)
	case stage.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Stage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stage.FieldMusicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMusicID(v)
		return nil
	case stage.FieldLevelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelName(v)
		return nil
	case stage.FieldDifficulty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case stage.FieldLevelAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelAddress(v)
		return nil
	case stage.FieldJacketAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJacketAddress(v)
		return nil
	case stage.FieldTotalNotes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalNotes(v)
		return nil
	case stage.FieldMaxCombo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxCombo(v)
		return nil
	case stage.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Stage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StageMutation) AddedFields() []string {
	var fields []string
	if m.adddifficulty != nil {
		fields = append(fields, stage.FieldDifficulty)
	}
	if m.addtotal_notes != nil {
		fields = append(fields, stage.FieldTotalNotes)
	}
	if m.addmax_combo != nil {
		fields = append(fields, stage.FieldMaxCombo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stage.FieldDifficulty:
		return m.AddedDifficulty()
	case stage.FieldTotalNotes:
		return m.AddedTotalNotes()
	case stage.FieldMaxCombo:
		return m.AddedMaxCombo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stage.FieldDifficulty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDifficulty(v)
		return nil
	case stage.FieldTotalNotes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalNotes(v)
		return nil
	case stage.FieldMaxCombo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxCombo(v)
		return nil
	}
	return fmt.Errorf("unknown Stage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StageMutation) ResetField(name string) error {
	switch name {
	case stage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stage.FieldMusicID:
		m.ResetMusicID()
		return nil
	case stage.FieldLevelName:
		m.ResetLevelName()
		return nil
	case stage.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case stage.FieldLevelAddress:
		m.ResetLevelAddress()
		return nil
	case stage.FieldJacketAddress:
		m.ResetJacketAddress()
		return nil
	case stage.FieldTotalNotes:
		m.ResetTotalNotes()
		return nil
	case stage.FieldMaxCombo:
		m.ResetMaxCombo()
		return nil
	case stage.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Stage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.music != nil {
		edges = append(edges, stage.EdgeMusic)
	}
	if m.records != nil {
		edges = append(edges, stage.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stage.EdgeMusic:
		if id := m.music; id != nil {
			return []ent.Value{*id}
		}
	case stage.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrecords != nil {
		edges = append(edges, stage.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stage.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmusic {
		edges = append(edges, stage.EdgeMusic)
	}
	if m.clearedrecords {
		edges = append(edges, stage.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StageMutation) EdgeCleared(name string) bool {
	switch name {
	case stage.EdgeMusic:
		return m.clearedmusic
	case stage.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StageMutation) ClearEdge(name string) error {
	switch name {
	case stage.EdgeMusic:
		m.ClearMusic()
		return nil
	}
	return fmt.Errorf("unknown Stage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StageMutation) ResetEdge(name string) error {
	switch name {
	case stage.EdgeMusic:
		m.ResetMusic()
		return nil
	case stage.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown Stage edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	platform_type             *user.PlatformType
	platform_user_id          *string
	platform_email            *string
	platform_avatar_url       *string
	platform_display_name     *string
	language                  *string
	platform_data             *map[string]interface{}
	is_verified               *bool
	nickname                  *string
	display_name              *string
	last_login_at             *time.Time
	level                     *int
	addlevel                  *int
	exp                       *int
	addexp                    *int
	coin                      *int
	addcoin                   *int
	gem                       *int
	addgem                    *int
	settings                  *map[string]interface{}
	customize_data            *map[string]interface{}
	save_data                 *map[string]interface{}
	is_banned                 *bool
	banned_until              *time.Time
	ban_reason                *string
	clearedFields             map[string]struct{}
	purchased_products        map[uuid.UUID]struct{}
	removedpurchased_products map[uuid.UUID]struct{}
	clearedpurchased_products bool
	records                   map[uuid.UUID]struct{}
	removedrecords            map[uuid.UUID]struct{}
	clearedrecords            bool
	user_achievements         map[uuid.UUID]struct{}
	removeduser_achievements  map[uuid.UUID]struct{}
	cleareduser_achievements  bool
	user_purchases            map[uuid.UUID]struct{}
	removeduser_purchases     map[uuid.UUID]struct{}
	cleareduser_purchases     bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPlatformType sets the "platform_type" field.
func (m *UserMutation) SetPlatformType(ut user.PlatformType) {
	m.platform_type = &ut
}

// PlatformType returns the value of the "platform_type" field in the mutation.
func (m *UserMutation) PlatformType() (r user.PlatformType, exists bool) {
	v := m.platform_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformType returns the old "platform_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformType(ctx context.Context) (v user.PlatformType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformType: %w", err)
	}
	return oldValue.PlatformType, nil
}

// ResetPlatformType resets all changes to the "platform_type" field.
func (m *UserMutation) ResetPlatformType() {
	m.platform_type = nil
}

// SetPlatformUserID sets the "platform_user_id" field.
func (m *UserMutation) SetPlatformUserID(s string) {
	m.platform_user_id = &s
}

// PlatformUserID returns the value of the "platform_user_id" field in the mutation.
func (m *UserMutation) PlatformUserID() (r string, exists bool) {
	v := m.platform_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformUserID returns the old "platform_user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformUserID: %w", err)
	}
	return oldValue.PlatformUserID, nil
}

// ResetPlatformUserID resets all changes to the "platform_user_id" field.
func (m *UserMutation) ResetPlatformUserID() {
	m.platform_user_id = nil
}

// SetPlatformEmail sets the "platform_email" field.
func (m *UserMutation) SetPlatformEmail(s string) {
	m.platform_email = &s
}

// PlatformEmail returns the value of the "platform_email" field in the mutation.
func (m *UserMutation) PlatformEmail() (r string, exists bool) {
	v := m.platform_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformEmail returns the old "platform_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformEmail: %w", err)
	}
	return oldValue.PlatformEmail, nil
}

// ClearPlatformEmail clears the value of the "platform_email" field.
func (m *UserMutation) ClearPlatformEmail() {
	m.platform_email = nil
	m.clearedFields[user.FieldPlatformEmail] = struct{}{}
}

// PlatformEmailCleared returns if the "platform_email" field was cleared in this mutation.
func (m *UserMutation) PlatformEmailCleared() bool {
	_, ok := m.clearedFields[user.FieldPlatformEmail]
	return ok
}

// ResetPlatformEmail resets all changes to the "platform_email" field.
func (m *UserMutation) ResetPlatformEmail() {
	m.platform_email = nil
	delete(m.clearedFields, user.FieldPlatformEmail)
}

// SetPlatformAvatarURL sets the "platform_avatar_url" field.
func (m *UserMutation) SetPlatformAvatarURL(s string) {
	m.platform_avatar_url = &s
}

// PlatformAvatarURL returns the value of the "platform_avatar_url" field in the mutation.
func (m *UserMutation) PlatformAvatarURL() (r string, exists bool) {
	v := m.platform_avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAvatarURL returns the old "platform_avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAvatarURL: %w", err)
	}
	return oldValue.PlatformAvatarURL, nil
}

// ClearPlatformAvatarURL clears the value of the "platform_avatar_url" field.
func (m *UserMutation) ClearPlatformAvatarURL() {
	m.platform_avatar_url = nil
	m.clearedFields[user.FieldPlatformAvatarURL] = struct{}{}
}

// PlatformAvatarURLCleared returns if the "platform_avatar_url" field was cleared in this mutation.
func (m *UserMutation) PlatformAvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldPlatformAvatarURL]
	return ok
}

// ResetPlatformAvatarURL resets all changes to the "platform_avatar_url" field.
func (m *UserMutation) ResetPlatformAvatarURL() {
	m.platform_avatar_url = nil
	delete(m.clearedFields, user.FieldPlatformAvatarURL)
}

// SetPlatformDisplayName sets the "platform_display_name" field.
func (m *UserMutation) SetPlatformDisplayName(s string) {
	m.platform_display_name = &s
}

// PlatformDisplayName returns the value of the "platform_display_name" field in the mutation.
func (m *UserMutation) PlatformDisplayName() (r string, exists bool) {
	v := m.platform_display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformDisplayName returns the old "platform_display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformDisplayName: %w", err)
	}
	return oldValue.PlatformDisplayName, nil
}

// ClearPlatformDisplayName clears the value of the "platform_display_name" field.
func (m *UserMutation) ClearPlatformDisplayName() {
	m.platform_display_name = nil
	m.clearedFields[user.FieldPlatformDisplayName] = struct{}{}
}

// PlatformDisplayNameCleared returns if the "platform_display_name" field was cleared in this mutation.
func (m *UserMutation) PlatformDisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldPlatformDisplayName]
	return ok
}

// ResetPlatformDisplayName resets all changes to the "platform_display_name" field.
func (m *UserMutation) ResetPlatformDisplayName() {
	m.platform_display_name = nil
	delete(m.clearedFields, user.FieldPlatformDisplayName)
}

// SetLanguage sets the "language" field.
func (m *UserMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserMutation) ResetLanguage() {
	m.language = nil
}

// SetPlatformData sets the "platform_data" field.
func (m *UserMutation) SetPlatformData(value map[string]interface{}) {
	m.platform_data = &value
}

// PlatformData returns the value of the "platform_data" field in the mutation.
func (m *UserMutation) PlatformData() (r map[string]interface{}, exists bool) {
	v := m.platform_data
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformData returns the old "platform_data" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformData: %w", err)
	}
	return oldValue.PlatformData, nil
}

// ClearPlatformData clears the value of the "platform_data" field.
func (m *UserMutation) ClearPlatformData() {
	m.platform_data = nil
	m.clearedFields[user.FieldPlatformData] = struct{}{}
}

// PlatformDataCleared returns if the "platform_data" field was cleared in this mutation.
func (m *UserMutation) PlatformDataCleared() bool {
	_, ok := m.clearedFields[user.FieldPlatformData]
	return ok
}

// ResetPlatformData resets all changes to the "platform_data" field.
func (m *UserMutation) ResetPlatformData() {
	m.platform_data = nil
	delete(m.clearedFields, user.FieldPlatformData)
}

// SetIsVerified sets the "is_verified" field.
func (m *UserMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
}

// SetLevel sets the "level" field.
func (m *UserMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *UserMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *UserMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *UserMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *UserMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetExp sets the "exp" field.
func (m *UserMutation) SetExp(i int) {
	m.exp = &i
	m.addexp = nil
}

// Exp returns the value of the "exp" field in the mutation.
func (m *UserMutation) Exp() (r int, exists bool) {
	v := m.exp
	if v == nil {
		return
	}
	return *v, true
}

// OldExp returns the old "exp" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExp: %w", err)
	}
	return oldValue.Exp, nil
}

// AddExp adds i to the "exp" field.
func (m *UserMutation) AddExp(i int) {
	if m.addexp != nil {
		*m.addexp += i
	} else {
		m.addexp = &i
	}
}

// AddedExp returns the value that was added to the "exp" field in this mutation.
func (m *UserMutation) AddedExp() (r int, exists bool) {
	v := m.addexp
	if v == nil {
		return
	}
	return *v, true
}

// ResetExp resets all changes to the "exp" field.
func (m *UserMutation) ResetExp() {
	m.exp = nil
	m.addexp = nil
}

// SetCoin sets the "coin" field.
func (m *UserMutation) SetCoin(i int) {
	m.coin = &i
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *UserMutation) Coin() (r int, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCoin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds i to the "coin" field.
func (m *UserMutation) AddCoin(i int) {
	if m.addcoin != nil {
		*m.addcoin += i
	} else {
		m.addcoin = &i
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *UserMutation) AddedCoin() (r int, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoin resets all changes to the "coin" field.
func (m *UserMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
}

// SetGem sets the "gem" field.
func (m *UserMutation) SetGem(i int) {
	m.gem = &i
	m.addgem = nil
}

// Gem returns the value of the "gem" field in the mutation.
func (m *UserMutation) Gem() (r int, exists bool) {
	v := m.gem
	if v == nil {
		return
	}
	return *v, true
}

// OldGem returns the old "gem" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGem(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGem: %w", err)
	}
	return oldValue.Gem, nil
}

// AddGem adds i to the "gem" field.
func (m *UserMutation) AddGem(i int) {
	if m.addgem != nil {
		*m.addgem += i
	} else {
		m.addgem = &i
	}
}

// AddedGem returns the value that was added to the "gem" field in this mutation.
func (m *UserMutation) AddedGem() (r int, exists bool) {
	v := m.addgem
	if v == nil {
		return
	}
	return *v, true
}

// ResetGem resets all changes to the "gem" field.
func (m *UserMutation) ResetGem() {
	m.gem = nil
	m.addgem = nil
}

// SetSettings sets the "settings" field.
func (m *UserMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *UserMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *UserMutation) ResetSettings() {
	m.settings = nil
}

// SetCustomizeData sets the "customize_data" field.
func (m *UserMutation) SetCustomizeData(value map[string]interface{}) {
	m.customize_data = &value
}

// CustomizeData returns the value of the "customize_data" field in the mutation.
func (m *UserMutation) CustomizeData() (r map[string]interface{}, exists bool) {
	v := m.customize_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomizeData returns the old "customize_data" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCustomizeData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomizeData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomizeData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomizeData: %w", err)
	}
	return oldValue.CustomizeData, nil
}

// ResetCustomizeData resets all changes to the "customize_data" field.
func (m *UserMutation) ResetCustomizeData() {
	m.customize_data = nil
}

// SetSaveData sets the "save_data" field.
func (m *UserMutation) SetSaveData(value map[string]interface{}) {
	m.save_data = &value
}

// SaveData returns the value of the "save_data" field in the mutation.
func (m *UserMutation) SaveData() (r map[string]interface{}, exists bool) {
	v := m.save_data
	if v == nil {
		return
	}
	return *v, true
}

// OldSaveData returns the old "save_data" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSaveData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaveData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaveData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaveData: %w", err)
	}
	return oldValue.SaveData, nil
}

// ResetSaveData resets all changes to the "save_data" field.
func (m *UserMutation) ResetSaveData() {
	m.save_data = nil
}

// SetIsBanned sets the "is_banned" field.
func (m *UserMutation) SetIsBanned(b bool) {
	m.is_banned = &b
}

// IsBanned returns the value of the "is_banned" field in the mutation.
func (m *UserMutation) IsBanned() (r bool, exists bool) {
	v := m.is_banned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBanned returns the old "is_banned" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBanned: %w", err)
	}
	return oldValue.IsBanned, nil
}

// ResetIsBanned resets all changes to the "is_banned" field.
func (m *UserMutation) ResetIsBanned() {
	m.is_banned = nil
}

// SetBannedUntil sets the "banned_until" field.
func (m *UserMutation) SetBannedUntil(t time.Time) {
	m.banned_until = &t
}

// BannedUntil returns the value of the "banned_until" field in the mutation.
func (m *UserMutation) BannedUntil() (r time.Time, exists bool) {
	v := m.banned_until
	if v == nil {
		return
	}
	return *v, true
}

// OldBannedUntil returns the old "banned_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBannedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannedUntil: %w", err)
	}
	return oldValue.BannedUntil, nil
}

// ClearBannedUntil clears the value of the "banned_until" field.
func (m *UserMutation) ClearBannedUntil() {
	m.banned_until = nil
	m.clearedFields[user.FieldBannedUntil] = struct{}{}
}

// BannedUntilCleared returns if the "banned_until" field was cleared in this mutation.
func (m *UserMutation) BannedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldBannedUntil]
	return ok
}

// ResetBannedUntil resets all changes to the "banned_until" field.
func (m *UserMutation) ResetBannedUntil() {
	m.banned_until = nil
	delete(m.clearedFields, user.FieldBannedUntil)
}

// SetBanReason sets the "ban_reason" field.
func (m *UserMutation) SetBanReason(s string) {
	m.ban_reason = &s
}

// BanReason returns the value of the "ban_reason" field in the mutation.
func (m *UserMutation) BanReason() (r string, exists bool) {
	v := m.ban_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldBanReason returns the old "ban_reason" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBanReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanReason: %w", err)
	}
	return oldValue.BanReason, nil
}

// ClearBanReason clears the value of the "ban_reason" field.
func (m *UserMutation) ClearBanReason() {
	m.ban_reason = nil
	m.clearedFields[user.FieldBanReason] = struct{}{}
}

// BanReasonCleared returns if the "ban_reason" field was cleared in this mutation.
func (m *UserMutation) BanReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldBanReason]
	return ok
}

// ResetBanReason resets all changes to the "ban_reason" field.
func (m *UserMutation) ResetBanReason() {
	m.ban_reason = nil
	delete(m.clearedFields, user.FieldBanReason)
}

// AddPurchasedProductIDs adds the "purchased_products" edge to the Product entity by ids.
func (m *UserMutation) AddPurchasedProductIDs(ids ...uuid.UUID) {
	if m.purchased_products == nil {
		m.purchased_products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.purchased_products[ids[i]] = struct{}{}
	}
}

// ClearPurchasedProducts clears the "purchased_products" edge to the Product entity.
func (m *UserMutation) ClearPurchasedProducts() {
	m.clearedpurchased_products = true
}

// PurchasedProductsCleared reports if the "purchased_products" edge to the Product entity was cleared.
func (m *UserMutation) PurchasedProductsCleared() bool {
	return m.clearedpurchased_products
}

// RemovePurchasedProductIDs removes the "purchased_products" edge to the Product entity by IDs.
func (m *UserMutation) RemovePurchasedProductIDs(ids ...uuid.UUID) {
	if m.removedpurchased_products == nil {
		m.removedpurchased_products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.purchased_products, ids[i])
		m.removedpurchased_products[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedProducts returns the removed IDs of the "purchased_products" edge to the Product entity.
func (m *UserMutation) RemovedPurchasedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedpurchased_products {
		ids = append(ids, id)
	}
	return
}

// PurchasedProductsIDs returns the "purchased_products" edge IDs in the mutation.
func (m *UserMutation) PurchasedProductsIDs() (ids []uuid.UUID) {
	for id := range m.purchased_products {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedProducts resets all changes to the "purchased_products" edge.
func (m *UserMutation) ResetPurchasedProducts() {
	m.purchased_products = nil
	m.clearedpurchased_products = false
	m.removedpurchased_products = nil
}

// AddRecordIDs adds the "records" edge to the Record entity by ids.
func (m *UserMutation) AddRecordIDs(ids ...uuid.UUID) {
	if m.records == nil {
		m.records = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the Record entity.
func (m *UserMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the Record entity was cleared.
func (m *UserMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the Record entity by IDs.
func (m *UserMutation) RemoveRecordIDs(ids ...uuid.UUID) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the Record entity.
func (m *UserMutation) RemovedRecordsIDs() (ids []uuid.UUID) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *UserMutation) RecordsIDs() (ids []uuid.UUID) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *UserMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// AddUserAchievementIDs adds the "user_achievements" edge to the UserAchievement entity by ids.
func (m *UserMutation) AddUserAchievementIDs(ids ...uuid.UUID) {
	if m.user_achievements == nil {
		m.user_achievements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_achievements[ids[i]] = struct{}{}
	}
}

// ClearUserAchievements clears the "user_achievements" edge to the UserAchievement entity.
func (m *UserMutation) ClearUserAchievements() {
	m.cleareduser_achievements = true
}

// UserAchievementsCleared reports if the "user_achievements" edge to the UserAchievement entity was cleared.
func (m *UserMutation) UserAchievementsCleared() bool {
	return m.cleareduser_achievements
}

// RemoveUserAchievementIDs removes the "user_achievements" edge to the UserAchievement entity by IDs.
func (m *UserMutation) RemoveUserAchievementIDs(ids ...uuid.UUID) {
	if m.removeduser_achievements == nil {
		m.removeduser_achievements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_achievements, ids[i])
		m.removeduser_achievements[ids[i]] = struct{}{}
	}
}

// RemovedUserAchievements returns the removed IDs of the "user_achievements" edge to the UserAchievement entity.
func (m *UserMutation) RemovedUserAchievementsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_achievements {
		ids = append(ids, id)
	}
	return
}

// UserAchievementsIDs returns the "user_achievements" edge IDs in the mutation.
func (m *UserMutation) UserAchievementsIDs() (ids []uuid.UUID) {
	for id := range m.user_achievements {
		ids = append(ids, id)
	}
	return
}

// ResetUserAchievements resets all changes to the "user_achievements" edge.
func (m *UserMutation) ResetUserAchievements() {
	m.user_achievements = nil
	m.cleareduser_achievements = false
	m.removeduser_achievements = nil
}

// AddUserPurchaseIDs adds the "user_purchases" edge to the UserPurchase entity by ids.
func (m *UserMutation) AddUserPurchaseIDs(ids ...uuid.UUID) {
	if m.user_purchases == nil {
		m.user_purchases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_purchases[ids[i]] = struct{}{}
	}
}

// ClearUserPurchases clears the "user_purchases" edge to the UserPurchase entity.
func (m *UserMutation) ClearUserPurchases() {
	m.cleareduser_purchases = true
}

// UserPurchasesCleared reports if the "user_purchases" edge to the UserPurchase entity was cleared.
func (m *UserMutation) UserPurchasesCleared() bool {
	return m.cleareduser_purchases
}

// RemoveUserPurchaseIDs removes the "user_purchases" edge to the UserPurchase entity by IDs.
func (m *UserMutation) RemoveUserPurchaseIDs(ids ...uuid.UUID) {
	if m.removeduser_purchases == nil {
		m.removeduser_purchases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_purchases, ids[i])
		m.removeduser_purchases[ids[i]] = struct{}{}
	}
}

// RemovedUserPurchases returns the removed IDs of the "user_purchases" edge to the UserPurchase entity.
func (m *UserMutation) RemovedUserPurchasesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_purchases {
		ids = append(ids, id)
	}
	return
}

// UserPurchasesIDs returns the "user_purchases" edge IDs in the mutation.
func (m *UserMutation) UserPurchasesIDs() (ids []uuid.UUID) {
	for id := range m.user_purchases {
		ids = append(ids, id)
	}
	return
}

// ResetUserPurchases resets all changes to the "user_purchases" edge.
func (m *UserMutation) ResetUserPurchases() {
	m.user_purchases = nil
	m.cleareduser_purchases = false
	m.removeduser_purchases = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.platform_type != nil {
		fields = append(fields, user.FieldPlatformType)
	}
	if m.platform_user_id != nil {
		fields = append(fields, user.FieldPlatformUserID)
	}
	if m.platform_email != nil {
		fields = append(fields, user.FieldPlatformEmail)
	}
	if m.platform_avatar_url != nil {
		fields = append(fields, user.FieldPlatformAvatarURL)
	}
	if m.platform_display_name != nil {
		fields = append(fields, user.FieldPlatformDisplayName)
	}
	if m.language != nil {
		fields = append(fields, user.FieldLanguage)
	}
	if m.platform_data != nil {
		fields = append(fields, user.FieldPlatformData)
	}
	if m.is_verified != nil {
		fields = append(fields, user.FieldIsVerified)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.level != nil {
		fields = append(fields, user.FieldLevel)
	}
	if m.exp != nil {
		fields = append(fields, user.FieldExp)
	}
	if m.coin != nil {
		fields = append(fields, user.FieldCoin)
	}
	if m.gem != nil {
		fields = append(fields, user.FieldGem)
	}
	if m.settings != nil {
		fields = append(fields, user.FieldSettings)
	}
	if m.customize_data != nil {
		fields = append(fields, user.FieldCustomizeData)
	}
	if m.save_data != nil {
		fields = append(fields, user.FieldSaveData)
	}
	if m.is_banned != nil {
		fields = append(fields, user.FieldIsBanned)
	}
	if m.banned_until != nil {
		fields = append(fields, user.FieldBannedUntil)
	}
	if m.ban_reason != nil {
		fields = append(fields, user.FieldBanReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldPlatformType:
		return m.PlatformType()
	case user.FieldPlatformUserID:
		return m.PlatformUserID()
	case user.FieldPlatformEmail:
		return m.PlatformEmail()
	case user.FieldPlatformAvatarURL:
		return m.PlatformAvatarURL()
	case user.FieldPlatformDisplayName:
		return m.PlatformDisplayName()
	case user.FieldLanguage:
		return m.Language()
	case user.FieldPlatformData:
		return m.PlatformData()
	case user.FieldIsVerified:
		return m.IsVerified()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldLevel:
		return m.Level()
	case user.FieldExp:
		return m.Exp()
	case user.FieldCoin:
		return m.Coin()
	case user.FieldGem:
		return m.Gem()
	case user.FieldSettings:
		return m.Settings()
	case user.FieldCustomizeData:
		return m.CustomizeData()
	case user.FieldSaveData:
		return m.SaveData()
	case user.FieldIsBanned:
		return m.IsBanned()
	case user.FieldBannedUntil:
		return m.BannedUntil()
	case user.FieldBanReason:
		return m.BanReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldPlatformType:
		return m.OldPlatformType(ctx)
	case user.FieldPlatformUserID:
		return m.OldPlatformUserID(ctx)
	case user.FieldPlatformEmail:
		return m.OldPlatformEmail(ctx)
	case user.FieldPlatformAvatarURL:
		return m.OldPlatformAvatarURL(ctx)
	case user.FieldPlatformDisplayName:
		return m.OldPlatformDisplayName(ctx)
	case user.FieldLanguage:
		return m.OldLanguage(ctx)
	case user.FieldPlatformData:
		return m.OldPlatformData(ctx)
	case user.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldLevel:
		return m.OldLevel(ctx)
	case user.FieldExp:
		return m.OldExp(ctx)
	case user.FieldCoin:
		return m.OldCoin(ctx)
	case user.FieldGem:
		return m.OldGem(ctx)
	case user.FieldSettings:
		return m.OldSettings(ctx)
	case user.FieldCustomizeData:
		return m.OldCustomizeData(ctx)
	case user.FieldSaveData:
		return m.OldSaveData(ctx)
	case user.FieldIsBanned:
		return m.OldIsBanned(ctx)
	case user.FieldBannedUntil:
		return m.OldBannedUntil(ctx)
	case user.FieldBanReason:
		return m.OldBanReason(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldPlatformType:
		v, ok := value.(user.PlatformType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformType(v)
		return nil
	case user.FieldPlatformUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformUserID(v)
		return nil
	case user.FieldPlatformEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformEmail(v)
		return nil
	case user.FieldPlatformAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAvatarURL(v)
		return nil
	case user.FieldPlatformDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformDisplayName(v)
		return nil
	case user.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case user.FieldPlatformData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformData(v)
		return nil
	case user.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case user.FieldExp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExp(v)
		return nil
	case user.FieldCoin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case user.FieldGem:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGem(v)
		return nil
	case user.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case user.FieldCustomizeData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomizeData(v)
		return nil
	case user.FieldSaveData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaveData(v)
		return nil
	case user.FieldIsBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBanned(v)
		return nil
	case user.FieldBannedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannedUntil(v)
		return nil
	case user.FieldBanReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanReason(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, user.FieldLevel)
	}
	if m.addexp != nil {
		fields = append(fields, user.FieldExp)
	}
	if m.addcoin != nil {
		fields = append(fields, user.FieldCoin)
	}
	if m.addgem != nil {
		fields = append(fields, user.FieldGem)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLevel:
		return m.AddedLevel()
	case user.FieldExp:
		return m.AddedExp()
	case user.FieldCoin:
		return m.AddedCoin()
	case user.FieldGem:
		return m.AddedGem()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case user.FieldExp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExp(v)
		return nil
	case user.FieldCoin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case user.FieldGem:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGem(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPlatformEmail) {
		fields = append(fields, user.FieldPlatformEmail)
	}
	if m.FieldCleared(user.FieldPlatformAvatarURL) {
		fields = append(fields, user.FieldPlatformAvatarURL)
	}
	if m.FieldCleared(user.FieldPlatformDisplayName) {
		fields = append(fields, user.FieldPlatformDisplayName)
	}
	if m.FieldCleared(user.FieldPlatformData) {
		fields = append(fields, user.FieldPlatformData)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldBannedUntil) {
		fields = append(fields, user.FieldBannedUntil)
	}
	if m.FieldCleared(user.FieldBanReason) {
		fields = append(fields, user.FieldBanReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPlatformEmail:
		m.ClearPlatformEmail()
		return nil
	case user.FieldPlatformAvatarURL:
		m.ClearPlatformAvatarURL()
		return nil
	case user.FieldPlatformDisplayName:
		m.ClearPlatformDisplayName()
		return nil
	case user.FieldPlatformData:
		m.ClearPlatformData()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldBannedUntil:
		m.ClearBannedUntil()
		return nil
	case user.FieldBanReason:
		m.ClearBanReason()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldPlatformType:
		m.ResetPlatformType()
		return nil
	case user.FieldPlatformUserID:
		m.ResetPlatformUserID()
		return nil
	case user.FieldPlatformEmail:
		m.ResetPlatformEmail()
		return nil
	case user.FieldPlatformAvatarURL:
		m.ResetPlatformAvatarURL()
		return nil
	case user.FieldPlatformDisplayName:
		m.ResetPlatformDisplayName()
		return nil
	case user.FieldLanguage:
		m.ResetLanguage()
		return nil
	case user.FieldPlatformData:
		m.ResetPlatformData()
		return nil
	case user.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldLevel:
		m.ResetLevel()
		return nil
	case user.FieldExp:
		m.ResetExp()
		return nil
	case user.FieldCoin:
		m.ResetCoin()
		return nil
	case user.FieldGem:
		m.ResetGem()
		return nil
	case user.FieldSettings:
		m.ResetSettings()
		return nil
	case user.FieldCustomizeData:
		m.ResetCustomizeData()
		return nil
	case user.FieldSaveData:
		m.ResetSaveData()
		return nil
	case user.FieldIsBanned:
		m.ResetIsBanned()
		return nil
	case user.FieldBannedUntil:
		m.ResetBannedUntil()
		return nil
	case user.FieldBanReason:
		m.ResetBanReason()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.purchased_products != nil {
		edges = append(edges, user.EdgePurchasedProducts)
	}
	if m.records != nil {
		edges = append(edges, user.EdgeRecords)
	}
	if m.user_achievements != nil {
		edges = append(edges, user.EdgeUserAchievements)
	}
	if m.user_purchases != nil {
		edges = append(edges, user.EdgeUserPurchases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePurchasedProducts:
		ids := make([]ent.Value, 0, len(m.purchased_products))
		for id := range m.purchased_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserAchievements:
		ids := make([]ent.Value, 0, len(m.user_achievements))
		for id := range m.user_achievements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPurchases:
		ids := make([]ent.Value, 0, len(m.user_purchases))
		for id := range m.user_purchases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpurchased_products != nil {
		edges = append(edges, user.EdgePurchasedProducts)
	}
	if m.removedrecords != nil {
		edges = append(edges, user.EdgeRecords)
	}
	if m.removeduser_achievements != nil {
		edges = append(edges, user.EdgeUserAchievements)
	}
	if m.removeduser_purchases != nil {
		edges = append(edges, user.EdgeUserPurchases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePurchasedProducts:
		ids := make([]ent.Value, 0, len(m.removedpurchased_products))
		for id := range m.removedpurchased_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserAchievements:
		ids := make([]ent.Value, 0, len(m.removeduser_achievements))
		for id := range m.removeduser_achievements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPurchases:
		ids := make([]ent.Value, 0, len(m.removeduser_purchases))
		for id := range m.removeduser_purchases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpurchased_products {
		edges = append(edges, user.EdgePurchasedProducts)
	}
	if m.clearedrecords {
		edges = append(edges, user.EdgeRecords)
	}
	if m.cleareduser_achievements {
		edges = append(edges, user.EdgeUserAchievements)
	}
	if m.cleareduser_purchases {
		edges = append(edges, user.EdgeUserPurchases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePurchasedProducts:
		return m.clearedpurchased_products
	case user.EdgeRecords:
		return m.clearedrecords
	case user.EdgeUserAchievements:
		return m.cleareduser_achievements
	case user.EdgeUserPurchases:
		return m.cleareduser_purchases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePurchasedProducts:
		m.ResetPurchasedProducts()
		return nil
	case user.EdgeRecords:
		m.ResetRecords()
		return nil
	case user.EdgeUserAchievements:
		m.ResetUserAchievements()
		return nil
	case user.EdgeUserPurchases:
		m.ResetUserPurchases()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAchievementMutation represents an operation that mutates the UserAchievement nodes in the graph.
type UserAchievementMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	unlocked_at        *time.Time
	progress_data      *map[string]interface{}
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	achievement        *uuid.UUID
	clearedachievement bool
	done               bool
	oldValue           func(context.Context) (*UserAchievement, error)
	predicates         []predicate.UserAchievement
}

var _ ent.Mutation = (*UserAchievementMutation)(nil)

// userachievementOption allows management of the mutation configuration using functional options.
type userachievementOption func(*UserAchievementMutation)

// newUserAchievementMutation creates new mutation for the UserAchievement entity.
func newUserAchievementMutation(c config, op Op, opts ...userachievementOption) *UserAchievementMutation {
	m := &UserAchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAchievementID sets the ID field of the mutation.
func withUserAchievementID(id uuid.UUID) userachievementOption {
	return func(m *UserAchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAchievement
		)
		m.oldValue = func(ctx context.Context) (*UserAchievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAchievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAchievement sets the old UserAchievement of the mutation.
func withUserAchievement(node *UserAchievement) userachievementOption {
	return func(m *UserAchievementMutation) {
		m.oldValue = func(context.Context) (*UserAchievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserAchievement entities.
func (m *UserAchievementMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAchievementMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAchievementMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAchievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAchievementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAchievementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAchievementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAchievementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAchievementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserAchievementMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAchievementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAchievementMutation) ResetUserID() {
	m.user = nil
}

// SetAchievementID sets the "achievement_id" field.
func (m *UserAchievementMutation) SetAchievementID(u uuid.UUID) {
	m.achievement = &u
}

// AchievementID returns the value of the "achievement_id" field in the mutation.
func (m *UserAchievementMutation) AchievementID() (r uuid.UUID, exists bool) {
	v := m.achievement
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievementID returns the old "achievement_id" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldAchievementID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievementID: %w", err)
	}
	return oldValue.AchievementID, nil
}

// ResetAchievementID resets all changes to the "achievement_id" field.
func (m *UserAchievementMutation) ResetAchievementID() {
	m.achievement = nil
}

// SetUnlockedAt sets the "unlocked_at" field.
func (m *UserAchievementMutation) SetUnlockedAt(t time.Time) {
	m.unlocked_at = &t
}

// UnlockedAt returns the value of the "unlocked_at" field in the mutation.
func (m *UserAchievementMutation) UnlockedAt() (r time.Time, exists bool) {
	v := m.unlocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockedAt returns the old "unlocked_at" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldUnlockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockedAt: %w", err)
	}
	return oldValue.UnlockedAt, nil
}

// ResetUnlockedAt resets all changes to the "unlocked_at" field.
func (m *UserAchievementMutation) ResetUnlockedAt() {
	m.unlocked_at = nil
}

// SetProgressData sets the "progress_data" field.
func (m *UserAchievementMutation) SetProgressData(value map[string]interface{}) {
	m.progress_data = &value
}

// ProgressData returns the value of the "progress_data" field in the mutation.
func (m *UserAchievementMutation) ProgressData() (r map[string]interface{}, exists bool) {
	v := m.progress_data
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressData returns the old "progress_data" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldProgressData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressData: %w", err)
	}
	return oldValue.ProgressData, nil
}

// ClearProgressData clears the value of the "progress_data" field.
func (m *UserAchievementMutation) ClearProgressData() {
	m.progress_data = nil
	m.clearedFields[userachievement.FieldProgressData] = struct{}{}
}

// ProgressDataCleared returns if the "progress_data" field was cleared in this mutation.
func (m *UserAchievementMutation) ProgressDataCleared() bool {
	_, ok := m.clearedFields[userachievement.FieldProgressData]
	return ok
}

// ResetProgressData resets all changes to the "progress_data" field.
func (m *UserAchievementMutation) ResetProgressData() {
	m.progress_data = nil
	delete(m.clearedFields, userachievement.FieldProgressData)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAchievementMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userachievement.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAchievementMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAchievementMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAchievementMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearAchievement clears the "achievement" edge to the Achievement entity.
func (m *UserAchievementMutation) ClearAchievement() {
	m.clearedachievement = true
	m.clearedFields[userachievement.FieldAchievementID] = struct{}{}
}

// AchievementCleared reports if the "achievement" edge to the Achievement entity was cleared.
func (m *UserAchievementMutation) AchievementCleared() bool {
	return m.clearedachievement
}

// AchievementIDs returns the "achievement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AchievementID instead. It exists only for internal usage by the builders.
func (m *UserAchievementMutation) AchievementIDs() (ids []uuid.UUID) {
	if id := m.achievement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAchievement resets all changes to the "achievement" edge.
func (m *UserAchievementMutation) ResetAchievement() {
	m.achievement = nil
	m.clearedachievement = false
}

// Where appends a list predicates to the UserAchievementMutation builder.
func (m *UserAchievementMutation) Where(ps ...predicate.UserAchievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAchievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAchievement).
func (m *UserAchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAchievementMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, userachievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userachievement.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userachievement.FieldUserID)
	}
	if m.achievement != nil {
		fields = append(fields, userachievement.FieldAchievementID)
	}
	if m.unlocked_at != nil {
		fields = append(fields, userachievement.FieldUnlockedAt)
	}
	if m.progress_data != nil {
		fields = append(fields, userachievement.FieldProgressData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userachievement.FieldCreatedAt:
		return m.CreatedAt()
	case userachievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case userachievement.FieldUserID:
		return m.UserID()
	case userachievement.FieldAchievementID:
		return m.AchievementID()
	case userachievement.FieldUnlockedAt:
		return m.UnlockedAt()
	case userachievement.FieldProgressData:
		return m.ProgressData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userachievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userachievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userachievement.FieldUserID:
		return m.OldUserID(ctx)
	case userachievement.FieldAchievementID:
		return m.OldAchievementID(ctx)
	case userachievement.FieldUnlockedAt:
		return m.OldUnlockedAt(ctx)
	case userachievement.FieldProgressData:
		return m.OldProgressData(ctx)
	}
	return nil, fmt.Errorf("unknown UserAchievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userachievement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userachievement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userachievement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userachievement.FieldAchievementID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievementID(v)
		return nil
	case userachievement.FieldUnlockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockedAt(v)
		return nil
	case userachievement.FieldProgressData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressData(v)
		return nil
	}
	return fmt.Errorf("unknown UserAchievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAchievementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAchievementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAchievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userachievement.FieldProgressData) {
		fields = append(fields, userachievement.FieldProgressData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAchievementMutation) ClearField(name string) error {
	switch name {
	case userachievement.FieldProgressData:
		m.ClearProgressData()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAchievementMutation) ResetField(name string) error {
	switch name {
	case userachievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userachievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userachievement.FieldUserID:
		m.ResetUserID()
		return nil
	case userachievement.FieldAchievementID:
		m.ResetAchievementID()
		return nil
	case userachievement.FieldUnlockedAt:
		m.ResetUnlockedAt()
		return nil
	case userachievement.FieldProgressData:
		m.ResetProgressData()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userachievement.EdgeUser)
	}
	if m.achievement != nil {
		edges = append(edges, userachievement.EdgeAchievement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAchievementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userachievement.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userachievement.EdgeAchievement:
		if id := m.achievement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userachievement.EdgeUser)
	}
	if m.clearedachievement {
		edges = append(edges, userachievement.EdgeAchievement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAchievementMutation) EdgeCleared(name string) bool {
	switch name {
	case userachievement.EdgeUser:
		return m.cleareduser
	case userachievement.EdgeAchievement:
		return m.clearedachievement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAchievementMutation) ClearEdge(name string) error {
	switch name {
	case userachievement.EdgeUser:
		m.ClearUser()
		return nil
	case userachievement.EdgeAchievement:
		m.ClearAchievement()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAchievementMutation) ResetEdge(name string) error {
	switch name {
	case userachievement.EdgeUser:
		m.ResetUser()
		return nil
	case userachievement.EdgeAchievement:
		m.ResetAchievement()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement edge %s", name)
}

// UserPurchaseMutation represents an operation that mutates the UserPurchase nodes in the graph.
type UserPurchaseMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	purchase_date  *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	product        *uuid.UUID
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*UserPurchase, error)
	predicates     []predicate.UserPurchase
}

var _ ent.Mutation = (*UserPurchaseMutation)(nil)

// userpurchaseOption allows management of the mutation configuration using functional options.
type userpurchaseOption func(*UserPurchaseMutation)

// newUserPurchaseMutation creates new mutation for the UserPurchase entity.
func newUserPurchaseMutation(c config, op Op, opts ...userpurchaseOption) *UserPurchaseMutation {
	m := &UserPurchaseMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPurchase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPurchaseID sets the ID field of the mutation.
func withUserPurchaseID(id uuid.UUID) userpurchaseOption {
	return func(m *UserPurchaseMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPurchase
		)
		m.oldValue = func(ctx context.Context) (*UserPurchase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPurchase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPurchase sets the old UserPurchase of the mutation.
func withUserPurchase(node *UserPurchase) userpurchaseOption {
	return func(m *UserPurchaseMutation) {
		m.oldValue = func(context.Context) (*UserPurchase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPurchaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPurchaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPurchase entities.
func (m *UserPurchaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPurchaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPurchaseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPurchase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPurchaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPurchaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPurchase entity.
// If the UserPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPurchaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPurchaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPurchaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPurchaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPurchase entity.
// If the UserPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPurchaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPurchaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserPurchaseMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPurchaseMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPurchase entity.
// If the UserPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPurchaseMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPurchaseMutation) ResetUserID() {
	m.user = nil
}

// SetProductID sets the "product_id" field.
func (m *UserPurchaseMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *UserPurchaseMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the UserPurchase entity.
// If the UserPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPurchaseMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *UserPurchaseMutation) ResetProductID() {
	m.product = nil
}

// SetPurchaseDate sets the "purchase_date" field.
func (m *UserPurchaseMutation) SetPurchaseDate(t time.Time) {
	m.purchase_date = &t
}

// PurchaseDate returns the value of the "purchase_date" field in the mutation.
func (m *UserPurchaseMutation) PurchaseDate() (r time.Time, exists bool) {
	v := m.purchase_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseDate returns the old "purchase_date" field's value of the UserPurchase entity.
// If the UserPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPurchaseMutation) OldPurchaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseDate: %w", err)
	}
	return oldValue.PurchaseDate, nil
}

// ResetPurchaseDate resets all changes to the "purchase_date" field.
func (m *UserPurchaseMutation) ResetPurchaseDate() {
	m.purchase_date = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPurchaseMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userpurchase.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPurchaseMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPurchaseMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPurchaseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *UserPurchaseMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[userpurchase.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *UserPurchaseMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *UserPurchaseMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *UserPurchaseMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the UserPurchaseMutation builder.
func (m *UserPurchaseMutation) Where(ps ...predicate.UserPurchase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPurchaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPurchaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPurchase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPurchaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPurchaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPurchase).
func (m *UserPurchaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPurchaseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userpurchase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userpurchase.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userpurchase.FieldUserID)
	}
	if m.product != nil {
		fields = append(fields, userpurchase.FieldProductID)
	}
	if m.purchase_date != nil {
		fields = append(fields, userpurchase.FieldPurchaseDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPurchaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpurchase.FieldCreatedAt:
		return m.CreatedAt()
	case userpurchase.FieldUpdatedAt:
		return m.UpdatedAt()
	case userpurchase.FieldUserID:
		return m.UserID()
	case userpurchase.FieldProductID:
		return m.ProductID()
	case userpurchase.FieldPurchaseDate:
		return m.PurchaseDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPurchaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpurchase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userpurchase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userpurchase.FieldUserID:
		return m.OldUserID(ctx)
	case userpurchase.FieldProductID:
		return m.OldProductID(ctx)
	case userpurchase.FieldPurchaseDate:
		return m.OldPurchaseDate(ctx)
	}
	return nil, fmt.Errorf("unknown UserPurchase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPurchaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpurchase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userpurchase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userpurchase.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpurchase.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case userpurchase.FieldPurchaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseDate(v)
		return nil
	}
	return fmt.Errorf("unknown UserPurchase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPurchaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPurchaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPurchaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPurchase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPurchaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPurchaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPurchaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserPurchase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPurchaseMutation) ResetField(name string) error {
	switch name {
	case userpurchase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userpurchase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userpurchase.FieldUserID:
		m.ResetUserID()
		return nil
	case userpurchase.FieldProductID:
		m.ResetProductID()
		return nil
	case userpurchase.FieldPurchaseDate:
		m.ResetPurchaseDate()
		return nil
	}
	return fmt.Errorf("unknown UserPurchase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPurchaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userpurchase.EdgeUser)
	}
	if m.product != nil {
		edges = append(edges, userpurchase.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPurchaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpurchase.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userpurchase.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPurchaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPurchaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPurchaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userpurchase.EdgeUser)
	}
	if m.clearedproduct {
		edges = append(edges, userpurchase.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPurchaseMutation) EdgeCleared(name string) bool {
	switch name {
	case userpurchase.EdgeUser:
		return m.cleareduser
	case userpurchase.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPurchaseMutation) ClearEdge(name string) error {
	switch name {
	case userpurchase.EdgeUser:
		m.ClearUser()
		return nil
	case userpurchase.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown UserPurchase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPurchaseMutation) ResetEdge(name string) error {
	switch name {
	case userpurchase.EdgeUser:
		m.ResetUser()
		return nil
	case userpurchase.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown UserPurchase edge %s", name)
}
